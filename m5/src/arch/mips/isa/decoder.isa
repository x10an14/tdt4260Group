// -*- mode:c++ -*-

// Copyright (c) 2007 MIPS Technologies, Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Korey Sewell
//          Brett Miller
//          Jaidev Patwardhan

////////////////////////////////////////////////////////////////////
//
// The actual MIPS32 ISA decoder
// -----------------------------
// The following instructions are specified in the MIPS32 ISA
// Specification. Decoding closely follows the style specified
// in the MIPS32 ISA specification document starting with Table
// A-2 (document available @ http://www.mips.com)
//
decode OPCODE_HI default Unknown::unknown() {
    //Table A-2
    0x0: decode OPCODE_LO {
        0x0: decode FUNCTION_HI {
            0x0: decode FUNCTION_LO {
                0x1: decode MOVCI {
                    format BasicOp {
                        0: movf({{
                            Rd = (getCondCode(FCSR, CC) == 0) ? Rd : Rs;
                        }});
                        1: movt({{
                            Rd = (getCondCode(FCSR, CC) == 1) ? Rd : Rs;
                        }});
                    }
                }

                format BasicOp {
                    //Table A-3 Note: "Specific encodings of the rd, rs, and
                    //rt fields are used to distinguish SLL, SSNOP, and EHB
                    //functions
                    0x0: decode RS  {
                        0x0: decode RT_RD {
                            0x0: decode SA default Nop::nop() {
                                 0x1: ssnop({{;}});
                                 0x3: ehb({{;}});
                            }
                            default: sll({{ Rd = Rt.uw << SA; }});
                        }
                    }

                    0x2: decode RS_SRL {
                        0x0:decode SRL {
                            0: srl({{ Rd = Rt.uw >> SA; }});

                            //Hardcoded assuming 32-bit ISA,
                            //probably need parameter here
                            1: rotr({{
                                Rd = (Rt.uw << (32 - SA)) | (Rt.uw >> SA);
                            }});
                        }
                    }

                    0x3: decode RS {
                        0x0: sra({{
                            uint32_t temp = Rt >> SA;
                            if ( (Rt & 0x80000000) > 0 ) {
                                uint32_t mask = 0x80000000;
                                for(int i=0; i < SA; i++) {
                                    temp |= mask;
                                    mask = mask >> 1;
                                }
                            }
                            Rd = temp;
                        }});
                    }

                    0x4: sllv({{ Rd = Rt.uw << Rs<4:0>; }});

                    0x6: decode SRLV {
                        0: srlv({{ Rd = Rt.uw >> Rs<4:0>; }});

                        //Hardcoded assuming 32-bit ISA,
                        //probably need parameter here
                        1: rotrv({{
                            Rd = (Rt.uw << (32 - Rs<4:0>)) |
                                 (Rt.uw >> Rs<4:0>);
                        }});
                    }

                    0x7: srav({{
                        int shift_amt = Rs<4:0>;

                        uint32_t temp = Rt >> shift_amt;

                        if ((Rt & 0x80000000) > 0) {
                            uint32_t mask = 0x80000000;
                            for (int i = 0; i < shift_amt; i++) {
                                temp |= mask;
                                mask = mask >> 1;
                            }
                        }
                        Rd = temp;
                    }});
                }
            }

            0x1: decode FUNCTION_LO {
                //Table A-3 Note: "Specific encodings of the hint field are
                //used to distinguish JR from JR.HB and JALR from JALR.HB"
                format Jump {
                    0x0: decode HINT {
                        0x1: jr_hb({{
                            Config1Reg config1 = Config1;
                            if (config1.ca == 0) {
                                NNPC = Rs;
                            } else {
                                panic("MIPS16e not supported\n");
                            }
                        }}, IsReturn, ClearHazards);
                        default: jr({{
                            Config1Reg config1 = Config1;
                            if (config1.ca == 0) {
                                NNPC = Rs;
                            } else {
                                panic("MIPS16e not supported\n");
                            }
                        }}, IsReturn);
                    }

                    0x1: decode HINT {
                        0x1: jalr_hb({{ Rd = NNPC; NNPC = Rs; }}, IsCall
                                     , ClearHazards);
                        default: jalr({{ Rd = NNPC; NNPC = Rs; }}, IsCall);
                    }
                }

                format BasicOp {
                    0x2: movz({{ Rd = (Rt == 0) ? Rs : Rd; }});
                    0x3: movn({{ Rd = (Rt != 0) ? Rs : Rd; }});
#if FULL_SYSTEM
                    0x4: syscall({{ fault = new SystemCallFault(); }});
#else
                    0x4: syscall({{ xc->syscall(R2); }},
                                 IsSerializeAfter, IsNonSpeculative);
#endif
                    0x7: sync({{ ; }}, IsMemBarrier);
                    0x5: break({{fault = new BreakpointFault();}});
                }

            }

            0x2: decode FUNCTION_LO {
                0x0: HiLoRsSelOp::mfhi({{ Rd = HI_RS_SEL; }},
                             IntMultOp, IsIprAccess);
                0x1: HiLoRdSelOp::mthi({{ HI_RD_SEL = Rs; }});
                0x2: HiLoRsSelOp::mflo({{ Rd = LO_RS_SEL; }},
                             IntMultOp, IsIprAccess);
                0x3: HiLoRdSelOp::mtlo({{ LO_RD_SEL = Rs; }});
            }

            0x3: decode FUNCTION_LO {
                format HiLoRdSelValOp {
                    0x0: mult({{ val = Rs.sd * Rt.sd; }}, IntMultOp);
                    0x1: multu({{ val = Rs.ud * Rt.ud; }}, IntMultOp);
                }

                format HiLoOp {
                    0x2: div({{
                        if (Rt.sd != 0) {
                            HI0 = Rs.sd % Rt.sd;
                            LO0 = Rs.sd / Rt.sd;
                        }
                    }}, IntDivOp);

                    0x3: divu({{
                        if (Rt.ud != 0) {
                            HI0 = Rs.ud % Rt.ud;
                            LO0 = Rs.ud / Rt.ud;
                        }
                    }}, IntDivOp);
                }
            }

            0x4: decode HINT {
                0x0: decode FUNCTION_LO {
                    format IntOp {
                        0x0: add({{
                            /* More complicated since an ADD can cause 
                               an arithmetic overflow exception */
                            int64_t Src1 = Rs.sw;
                            int64_t Src2 = Rt.sw;
                            int64_t temp_result;
#if FULL_SYSTEM
                            if (((Src1 >> 31) & 1) == 1)
                                Src1 |= 0x100000000LL;
#endif
                            temp_result = Src1 + Src2;
#if FULL_SYSTEM
                            if (bits(temp_result, 31) ==
                                bits(temp_result, 32)) {
#endif
                                Rd.sw = temp_result;
#if FULL_SYSTEM
                            } else {
                                fault = new ArithmeticFault();
                            }
#endif
                        }});
                        0x1: addu({{ Rd.sw = Rs.sw + Rt.sw;}});
                        0x2: sub({{
                            /* More complicated since an SUB can cause
                               an arithmetic overflow exception */
                            int64_t Src1 = Rs.sw;
                            int64_t Src2 = Rt.sw;
                            int64_t temp_result = Src1 - Src2;
#if  FULL_SYSTEM
                            if (bits(temp_result, 31) == 
                                bits(temp_result, 32)) {
#endif
                                Rd.sw = temp_result;
#if  FULL_SYSTEM
                            } else {
                                fault = new ArithmeticFault();
                            }
#endif
                        }});
                        0x3: subu({{ Rd.sw = Rs.sw - Rt.sw; }});
                        0x4: and({{ Rd = Rs & Rt; }});
                        0x5: or({{ Rd = Rs | Rt; }});
                        0x6: xor({{ Rd = Rs ^ Rt; }});
                        0x7: nor({{ Rd = ~(Rs | Rt); }});
                    }
                }
            }

            0x5: decode HINT {
                0x0: decode FUNCTION_LO {
                    format IntOp{
                        0x2: slt({{  Rd.sw = (Rs.sw < Rt.sw) ? 1 : 0 }});
                        0x3: sltu({{ Rd.uw = (Rs.uw < Rt.uw) ? 1 : 0 }});
                    }
                }
            }

            0x6: decode FUNCTION_LO {
                format Trap {
                    0x0: tge({{  cond = (Rs.sw >= Rt.sw); }});
                    0x1: tgeu({{ cond = (Rs.uw >= Rt.uw); }});
                    0x2: tlt({{ cond = (Rs.sw < Rt.sw); }});
                    0x3: tltu({{ cond = (Rs.uw < Rt.uw); }});
                    0x4: teq({{ cond = (Rs.sw == Rt.sw); }});
                    0x6: tne({{ cond = (Rs.sw != Rt.sw); }});
                }
            }
        }

        0x1: decode REGIMM_HI {
            0x0: decode REGIMM_LO {
                format Branch {
                    0x0: bltz({{ cond = (Rs.sw < 0); }});
                    0x1: bgez({{ cond = (Rs.sw >= 0); }});
                    0x2: bltzl({{ cond = (Rs.sw < 0); }}, Likely);
                    0x3: bgezl({{ cond = (Rs.sw >= 0); }}, Likely);
                }
            }

            0x1: decode REGIMM_LO {
                format TrapImm {
                    0x0: tgei( {{ cond = (Rs.sw >= (int16_t)INTIMM); }});
                    0x1: tgeiu({{
                        cond = (Rs.uw >= (uint32_t)(int32_t)(int16_t)INTIMM);
                    }});
                    0x2: tlti( {{ cond = (Rs.sw < (int16_t)INTIMM); }});
                    0x3: tltiu({{
                        cond = (Rs.uw < (uint32_t)(int32_t)(int16_t)INTIMM);
                    }});
                    0x4: teqi( {{ cond = (Rs.sw == (int16_t)INTIMM); }});
                    0x6: tnei( {{ cond = (Rs.sw != (int16_t)INTIMM); }});
                }
            }

            0x2: decode REGIMM_LO {
                format Branch {
                    0x0: bltzal({{ cond = (Rs.sw < 0); }}, Link);
                    0x1: decode RS {
                        0x0: bal ({{ cond = 1; }}, IsCall, Link);
                        default: bgezal({{ cond = (Rs.sw >= 0); }}, Link);
                    }
                    0x2: bltzall({{ cond = (Rs.sw < 0); }}, Link, Likely);
                    0x3: bgezall({{ cond = (Rs.sw >= 0); }}, Link, Likely);
                }
            }

            0x3: decode REGIMM_LO {
                // from Table 5-4 MIPS32 REGIMM Encoding of rt Field
                // (DSP ASE MANUAL)
                0x4: DspBranch::bposge32({{ cond = (dspctl<5:0> >= 32); }});
                format WarnUnimpl {
                    0x7: synci();
                }
            }
        }

        format Jump {
            0x2: j({{ NNPC = (NPC & 0xF0000000) | (JMPTARG << 2); }});
            0x3: jal({{ NNPC = (NPC & 0xF0000000) | (JMPTARG << 2); }},
                    IsCall, Link);
        }

        format Branch {
            0x4: decode RS_RT  {
                0x0: b({{ cond = 1; }});
                default: beq({{ cond = (Rs.sw == Rt.sw); }});
            }
            0x5: bne({{ cond = (Rs.sw != Rt.sw); }});
            0x6: blez({{ cond = (Rs.sw <= 0); }});
            0x7: bgtz({{ cond = (Rs.sw > 0); }});
        }
    }

    0x1: decode OPCODE_LO {
        format IntImmOp {
            0x0: addi({{
                int64_t Src1 = Rs.sw;
                int64_t Src2 = imm;
                int64_t temp_result;
#if  FULL_SYSTEM
                if (((Src1 >> 31) & 1) == 1)
                    Src1 |= 0x100000000LL;
#endif
                temp_result = Src1 + Src2;
#if  FULL_SYSTEM
                if (bits(temp_result, 31) == bits(temp_result, 32)) {
#endif
                    Rt.sw = temp_result;
#if  FULL_SYSTEM
                } else {
                    fault = new ArithmeticFault();
                }
#endif
            }});
            0x1: addiu({{ Rt.sw = Rs.sw + imm; }});
            0x2: slti({{ Rt.sw = (Rs.sw < imm) ? 1 : 0 }});

            //Edited to include MIPS AVP Pass/Fail instructions and
            //default to the sltiu instruction
            0x3: decode RS_RT_INTIMM {
                0xabc1: BasicOp::fail({{
                    exitSimLoop("AVP/SRVP Test Failed");
                }});
                0xabc2: BasicOp::pass({{
                    exitSimLoop("AVP/SRVP Test Passed");
                }});
                default: sltiu({{
                    Rt.uw = (Rs.uw < (uint32_t)sextImm) ? 1 : 0;
                }});
            }

            0x4: andi({{ Rt.sw = Rs.sw & zextImm; }});
            0x5: ori({{ Rt.sw = Rs.sw | zextImm; }});
            0x6: xori({{ Rt.sw = Rs.sw ^ zextImm; }});

            0x7: decode RS {
                0x0: lui({{ Rt = imm << 16; }});
            }
        }
    }

    0x2: decode OPCODE_LO {
        //Table A-11 MIPS32 COP0 Encoding of rs Field
        0x0: decode RS_MSB {
            0x0: decode RS {
                format CP0Control {
                    0x0: mfc0({{
                        Config3Reg config3 = Config3;
                        PageGrainReg pageGrain = PageGrain;
                        Rt = CP0_RD_SEL;
                        /* Hack for PageMask */
                        if (RD == 5) {
                            // PageMask
                            if (config3.sp == 0 || pageGrain.esp == 0)
                                Rt &= 0xFFFFE7FF;
                        }
                    }});
                    0x4: mtc0({{ 
                        CP0_RD_SEL = Rt;
                        CauseReg cause = Cause;
                        IntCtlReg intCtl = IntCtl;
                        if (RD == 11) {
                            // Compare
                            if (cause.ti == 1) {
                                cause.ti = 0;
                                int offset = 10; // corresponding to cause.ip0
                                offset += intCtl.ipti - 2;
                                replaceBits(cause, offset, offset, 0);
                            }
                        }
                        Cause = cause;
                    }});
                }
                format CP0Unimpl {
                    0x1: dmfc0();
                    0x5: dmtc0();
                    default: unknown();
                }
                format MT_MFTR {
                    // Decode MIPS MT MFTR instruction into sub-instructions
                    0x8: decode MT_U {
                        0x0: mftc0({{
                            data = xc->readRegOtherThread((RT << 3 | SEL) +
                                                          Ctrl_Base_DepTag);
                        }});
                        0x1: decode SEL {
                            0x0: mftgpr({{
                                data = xc->readRegOtherThread(RT);
                            }});
                            0x1: decode RT {
                                0x0: mftlo_dsp0({{ data = xc->readRegOtherThread(INTREG_DSP_LO0); }});
                                0x1: mfthi_dsp0({{ data = xc->readRegOtherThread(INTREG_DSP_HI0); }});
                                0x2: mftacx_dsp0({{ data = xc->readRegOtherThread(INTREG_DSP_ACX0); }});
                                0x4: mftlo_dsp1({{ data = xc->readRegOtherThread(INTREG_DSP_LO1); }});
                                0x5: mfthi_dsp1({{ data = xc->readRegOtherThread(INTREG_DSP_HI1); }});
                                0x6: mftacx_dsp1({{ data = xc->readRegOtherThread(INTREG_DSP_ACX1); }});
                                0x8: mftlo_dsp2({{ data = xc->readRegOtherThread(INTREG_DSP_LO2); }});
                                0x9: mfthi_dsp2({{ data = xc->readRegOtherThread(INTREG_DSP_HI2); }});
                                0x10: mftacx_dsp2({{ data = xc->readRegOtherThread(INTREG_DSP_ACX2); }});
                                0x12: mftlo_dsp3({{ data = xc->readRegOtherThread(INTREG_DSP_LO3); }});
                                0x13: mfthi_dsp3({{ data = xc->readRegOtherThread(INTREG_DSP_HI3); }});
                                0x14: mftacx_dsp3({{ data = xc->readRegOtherThread(INTREG_DSP_ACX3); }});
                                0x16: mftdsp({{ data = xc->readRegOtherThread(INTREG_DSP_CONTROL); }});
                                default: CP0Unimpl::unknown();
                            }
                            0x2: decode MT_H {
                                0x0: mftc1({{ data = xc->readRegOtherThread(RT +
                                                                            FP_Base_DepTag);
                                }});
                                0x1: mfthc1({{ data = xc->readRegOtherThread(RT +
                                                                             FP_Base_DepTag);
                                }});
                            }
                            0x3: cftc1({{
                                uint32_t fcsr_val = xc->readRegOtherThread(FLOATREG_FCSR +
                                                                            FP_Base_DepTag);
                                switch (RT) {
                                  case 0:
                                    data = xc->readRegOtherThread(FLOATREG_FIR +
                                                                  Ctrl_Base_DepTag);
                                    break;
                                  case 25:
                                    data = (fcsr_val & 0xFE000000 >> 24) |
                                           (fcsr_val & 0x00800000 >> 23);
                                    break;
                                  case 26:
                                    data = fcsr_val & 0x0003F07C;
                                    break;
                                  case 28:
                                    data = (fcsr_val & 0x00000F80) |
                                           (fcsr_val & 0x01000000 >> 21) |
                                           (fcsr_val & 0x00000003);
                                    break;
                                  case 31:
                                    data = fcsr_val;
                                    break;
                                  default:
                                    fatal("FP Control Value (%d) Not Valid");
                                }
                            }});
                            default: CP0Unimpl::unknown();
                        }
                    }
                }

                format MT_MTTR {
                    // Decode MIPS MT MTTR instruction into sub-instructions
                    0xC: decode MT_U {
                        0x0: mttc0({{ xc->setRegOtherThread((RD << 3 | SEL) + Ctrl_Base_DepTag,
                                                            Rt);
                                   }});
                        0x1: decode SEL {
                            0x0: mttgpr({{ xc->setRegOtherThread(RD, Rt); }});
                            0x1: decode RT {
                                0x0: mttlo_dsp0({{ xc->setRegOtherThread(INTREG_DSP_LO0, Rt);
                                                }});
                                0x1: mtthi_dsp0({{ xc->setRegOtherThread(INTREG_DSP_HI0,
                                                                         Rt);
                                                }});
                                0x2: mttacx_dsp0({{ xc->setRegOtherThread(INTREG_DSP_ACX0,
                                                                          Rt);
                                                 }});
                                0x4: mttlo_dsp1({{ xc->setRegOtherThread(INTREG_DSP_LO1,
                                                                         Rt);
                                                }});
                                0x5: mtthi_dsp1({{ xc->setRegOtherThread(INTREG_DSP_HI1,
                                                                         Rt);
                                                }});
                                0x6: mttacx_dsp1({{ xc->setRegOtherThread(INTREG_DSP_ACX1,
                                                                          Rt);
                                                 }});
                                0x8: mttlo_dsp2({{ xc->setRegOtherThread(INTREG_DSP_LO2,
                                                                         Rt);
                                                }});
                                0x9: mtthi_dsp2({{ xc->setRegOtherThread(INTREG_DSP_HI2,
                                                                         Rt);
                                                }});
                                0x10: mttacx_dsp2({{ xc->setRegOtherThread(INTREG_DSP_ACX2,
                                                                           Rt);
                                                  }});
                                0x12: mttlo_dsp3({{ xc->setRegOtherThread(INTREG_DSP_LO3,
                                                                          Rt);
                                                 }});
                                0x13: mtthi_dsp3({{ xc->setRegOtherThread(INTREG_DSP_HI3,
                                                                          Rt);
                                                 }});
                                0x14: mttacx_dsp3({{ xc->setRegOtherThread(INTREG_DSP_ACX3, Rt);
                                                  }});
                                0x16: mttdsp({{ xc->setRegOtherThread(INTREG_DSP_CONTROL, Rt); }});
                                default: CP0Unimpl::unknown();

                            }
                            0x2: mttc1({{
                                uint64_t data = xc->readRegOtherThread(RD +
                                                                       FP_Base_DepTag);
                                data = insertBits(data, top_bit,
                                                  bottom_bit, Rt);
                                xc->setRegOtherThread(RD + FP_Base_DepTag,
                                                      data);
                            }});
                            0x3: cttc1({{
                                uint32_t data;
                                switch (RD) {
                                  case 25:
                                    data = (Rt.uw<7:1> << 25) |  // move 31-25
                                           (FCSR & 0x01000000) | // bit 24
                                           (FCSR & 0x004FFFFF);  // bit 22-0
                                    break;
                                  case 26:
                                    data = (FCSR & 0xFFFC0000) | // move 31-18
                                           Rt.uw<17:12> << 12 |  // bit 17-12
                                           (FCSR & 0x00000F80) << 7 | // bit 11-7
                                           Rt.uw<6:2> << 2 |     // bit 6-2
                                           (FCSR & 0x00000002);  // bit 1...0
                                    break;
                                  case 28:
                                    data = (FCSR & 0xFE000000) | // move 31-25
                                           Rt.uw<2:2> << 24 |    // bit 24
                                           (FCSR & 0x00FFF000) << 23 | // bit 23-12
                                           Rt.uw<11:7> << 7 |    // bit 24
                                           (FCSR & 0x000007E) |
                                           Rt.uw<1:0>;           // bit 22-0
                                    break;
                                  case 31:
                                    data = Rt.uw;
                                    break;
                                  default:
                                    panic("FP Control Value (%d) "
                                            "Not Available. Ignoring "
                                            "Access to Floating Control "
                                            "Status Register", FS);
                                }
                                xc->setRegOtherThread(FLOATREG_FCSR + FP_Base_DepTag, data);
                            }});
                            default: CP0Unimpl::unknown();
                        }
                    }
                }
                0xB: decode RD {
                    format MT_Control {
                        0x0: decode POS {
                            0x0: decode SEL {
                                0x1: decode SC {
                                    0x0: dvpe({{
                                        MVPControlReg mvpControl = MVPControl;
                                        VPEConf0Reg vpeConf0 = VPEConf0;
                                        Rt = MVPControl;
                                        if (vpeConf0.mvp == 1)
                                            mvpControl.evp = 0;
                                        MVPControl = mvpControl;
                                    }});
                                    0x1: evpe({{
                                        MVPControlReg mvpControl = MVPControl;
                                        VPEConf0Reg vpeConf0 = VPEConf0;
                                        Rt = MVPControl;
                                        if (vpeConf0.mvp == 1)
                                            mvpControl.evp = 1;
                                        MVPControl = mvpControl;
                                    }});
                                   default:CP0Unimpl::unknown();
                                }
                                default:CP0Unimpl::unknown();
                            }
                            default:CP0Unimpl::unknown();
                        }
                        0x1: decode POS {
                            0xF: decode SEL {
                                0x1: decode SC {
                                    0x0: dmt({{
                                        VPEControlReg vpeControl = VPEControl;
                                        Rt = vpeControl;
                                        vpeControl.te = 0;
                                        VPEControl = vpeControl;
                                    }});
                                    0x1: emt({{
                                        VPEControlReg vpeControl = VPEControl;
                                        Rt = vpeControl;
                                        vpeControl.te = 1;
                                        VPEControl = vpeControl;
                                    }});
                                   default:CP0Unimpl::unknown();
                                }
                                default:CP0Unimpl::unknown();
                            }
                            default:CP0Unimpl::unknown();
                        }
                    }
                    0xC: decode POS {
                        0x0: decode SC {
                            0x0: CP0Control::di({{
                                StatusReg status = Status;
                                ConfigReg config = Config;
                                // Rev 2.0 or beyond?
                                if (config.ar >= 1) {
                                    Rt = status;
                                    status.ie = 0;
                                } else {
                                    // Enable this else branch once we
                                    // actually set values for Config on init
                                    fault = new ReservedInstructionFault();
                                }
                                Status = status;
                            }});
                            0x1: CP0Control::ei({{
                                StatusReg status = Status;
                                ConfigReg config = Config;
                                if (config.ar >= 1) {
                                    Rt = status;
                                    status.ie = 1;
                                } else {
                                    fault = new ReservedInstructionFault();
                                }
                            }});
                            default:CP0Unimpl::unknown();
                        }
                    }
                    default: CP0Unimpl::unknown();
                }
                format CP0Control {
                    0xA: rdpgpr({{
                        ConfigReg config = Config;
                        if (config.ar >= 1) {
                            // Rev 2 of the architecture
                            panic("Shadow Sets Not Fully Implemented.\n");
                        } else {
                          fault = new ReservedInstructionFault();
                        }
                    }});
                    0xE: wrpgpr({{
                        ConfigReg config = Config;
                        if (config.ar >= 1) {
                            // Rev 2 of the architecture
                            panic("Shadow Sets Not Fully Implemented.\n");
                        } else {
                            fault = new ReservedInstructionFault();
                        }
                    }});
                }
            }

            //Table A-12 MIPS32 COP0 Encoding of Function Field When rs=CO
            0x1: decode FUNCTION {
                format CP0Control {
                    0x18: eret({{
                        StatusReg status = Status;
                        ConfigReg config = Config;
                        SRSCtlReg srsCtl = SRSCtl;
                        DPRINTF(MipsPRA,"Restoring PC - %x\n",EPC);
                        if (status.erl == 1) {
                            status.erl = 0;
                            NPC = ErrorEPC;
                            // Need to adjust NNPC, otherwise things break
                            NNPC = ErrorEPC + sizeof(MachInst);
                        } else {
                            NPC = EPC;
                            // Need to adjust NNPC, otherwise things break
                            NNPC = EPC + sizeof(MachInst);
                            status.exl = 0;
                            if (config.ar >=1 &&
                                    srsCtl.hss > 0 &&
                                    status.bev == 0) {
                                srsCtl.css = srsCtl.pss;
                                //xc->setShadowSet(srsCtl.pss);
                            }
                        }
                        LLFlag = 0;
                        Status = status;
                        SRSCtl = srsCtl;
                    }}, IsReturn, IsSerializing, IsERET);

                    0x1F: deret({{
                        DebugReg debug = Debug;
                        if (debug.dm == 1) {
                            debug.dm = 1;
                            debug.iexi = 0;
                            NPC = DEPC;
                        } else {
                            // Undefined;
                        }
                        Debug = debug;
                    }}, IsReturn, IsSerializing, IsERET);
                }
                format CP0TLB {
                    0x01: tlbr({{
                        MipsISA::PTE *PTEntry =
                            xc->tcBase()->getITBPtr()->
                                getEntry(Index & 0x7FFFFFFF);
                        if (PTEntry == NULL) {
                            fatal("Invalid PTE Entry received on "
                                "a TLBR instruction\n");
                        }
                        /* Setup PageMask */
                        // If 1KB pages are not enabled, a read of PageMask
                        // must return 0b00 in bits 12, 11
                        PageMask = (PTEntry->Mask << 11);
                        /* Setup EntryHi */
                        EntryHi = ((PTEntry->VPN << 11) | (PTEntry->asid));
                        /* Setup Entry Lo0 */
                        EntryLo0 = ((PTEntry->PFN0 << 6) |
                                    (PTEntry->C0 << 3) |
                                    (PTEntry->D0 << 2) |
                                    (PTEntry->V0 << 1) |
                                    PTEntry->G);
                        /* Setup Entry Lo1 */
                        EntryLo1 = ((PTEntry->PFN1 << 6) |
                                    (PTEntry->C1 << 3) |
                                    (PTEntry->D1 << 2) |
                                    (PTEntry->V1 << 1) |
                                    PTEntry->G);
                    }}); // Need to hook up to TLB

                    0x02: tlbwi({{
                        //Create PTE
                        MipsISA::PTE newEntry;
                        //Write PTE
                        newEntry.Mask = (Addr)(PageMask >> 11);
                        newEntry.VPN = (Addr)(EntryHi >> 11);
                        /*  PageGrain _ ESP                    Config3 _ SP */
                        if (bits(PageGrain, 28) == 0 || bits(Config3, 4) ==0) {
                            // If 1KB pages are *NOT* enabled, lowest bits of
                            // the mask are 0b11 for TLB writes
                            newEntry.Mask |= 0x3;
                            // Reset bits 0 and 1 if 1KB pages are not enabled
                            newEntry.VPN &= 0xFFFFFFFC;
                        }
                        newEntry.asid = (uint8_t)(EntryHi & 0xFF);

                        newEntry.PFN0 = (Addr)(EntryLo0 >> 6);
                        newEntry.PFN1 = (Addr)(EntryLo1 >> 6);
                        newEntry.D0 = (bool)((EntryLo0 >> 2) & 1);
                        newEntry.D1 = (bool)((EntryLo1 >> 2) & 1);
                        newEntry.V1 = (bool)((EntryLo1 >> 1) & 1);
                        newEntry.V0 = (bool)((EntryLo0 >> 1) & 1);
                        newEntry.G = (bool)((EntryLo0 & EntryLo1) & 1);
                        newEntry.C0 = (uint8_t)((EntryLo0 >> 3) & 0x7);
                        newEntry.C1 = (uint8_t)((EntryLo1 >> 3) & 0x7);
                        /* Now, compute the AddrShiftAmount and OffsetMask -
                           TLB optimizations */
                        /* Addr Shift Amount for 1KB or larger pages */
                        if ((newEntry.Mask & 0xFFFF) == 3) {
                            newEntry.AddrShiftAmount = 12;
                        } else if ((newEntry.Mask & 0xFFFF) == 0x0000) {
                            newEntry.AddrShiftAmount = 10;
                        } else if ((newEntry.Mask & 0xFFFC) == 0x000C) {
                            newEntry.AddrShiftAmount = 14;
                        } else if ((newEntry.Mask & 0xFFF0) == 0x0030) {
                            newEntry.AddrShiftAmount = 16;
                        } else if ((newEntry.Mask & 0xFFC0) == 0x00C0) {
                            newEntry.AddrShiftAmount = 18;
                        } else if ((newEntry.Mask & 0xFF00) == 0x0300) {
                            newEntry.AddrShiftAmount = 20;
                        } else if ((newEntry.Mask & 0xFC00) == 0x0C00) {
                            newEntry.AddrShiftAmount = 22;
                        } else if ((newEntry.Mask & 0xF000) == 0x3000) {
                            newEntry.AddrShiftAmount = 24;
                        } else if ((newEntry.Mask & 0xC000) == 0xC000) {
                            newEntry.AddrShiftAmount = 26;
                        } else if ((newEntry.Mask & 0x30000) == 0x30000) {
                            newEntry.AddrShiftAmount = 28;
                        } else {
                            fatal("Invalid Mask Pattern Detected!\n");
                        }
                        newEntry.OffsetMask =
                            (1 << newEntry.AddrShiftAmount) - 1;

                        MipsISA::TLB *Ptr = xc->tcBase()->getITBPtr();
                        Config3Reg config3 = Config3;
                        PageGrainReg pageGrain = PageGrain;
                        int SP = 0;
                        if (bits(config3, config3.sp) == 1 &&
                            bits(pageGrain, pageGrain.esp) == 1) {
                            SP = 1;
                        }
                        IndexReg index = Index;
                        Ptr->insertAt(newEntry, Index & 0x7FFFFFFF, SP);
                    }});
                    0x06: tlbwr({{
                        //Create PTE
                        MipsISA::PTE newEntry;
                        //Write PTE
                        newEntry.Mask = (Addr)(PageMask >> 11);
                        newEntry.VPN = (Addr)(EntryHi >> 11);
                        /*  PageGrain _ ESP                    Config3 _ SP */
                        if (bits(PageGrain, 28) == 0 ||
                            bits(Config3, 4) == 0) {
                            // If 1KB pages are *NOT* enabled, lowest bits of
                            // the mask are 0b11 for TLB writes
                            newEntry.Mask |= 0x3;
                            // Reset bits 0 and 1 if 1KB pages are not enabled
                            newEntry.VPN &= 0xFFFFFFFC;
                        }
                        newEntry.asid = (uint8_t)(EntryHi & 0xFF);

                        newEntry.PFN0 = (Addr)(EntryLo0 >> 6);
                        newEntry.PFN1 = (Addr)(EntryLo1 >> 6);
                        newEntry.D0 = (bool)((EntryLo0 >> 2) & 1);
                        newEntry.D1 = (bool)((EntryLo1 >> 2) & 1);
                        newEntry.V1 = (bool)((EntryLo1 >> 1) & 1);
                        newEntry.V0 = (bool)((EntryLo0 >> 1) & 1);
                        newEntry.G = (bool)((EntryLo0 & EntryLo1) & 1);
                        newEntry.C0 = (uint8_t)((EntryLo0 >> 3) & 0x7);
                        newEntry.C1 = (uint8_t)((EntryLo1 >> 3) & 0x7);
                        /* Now, compute the AddrShiftAmount and OffsetMask -
                           TLB optimizations */
                        /* Addr Shift Amount for 1KB or larger pages */
                        if ((newEntry.Mask & 0xFFFF) == 3){
                            newEntry.AddrShiftAmount = 12;
                        } else if ((newEntry.Mask & 0xFFFF) == 0x0000) {
                            newEntry.AddrShiftAmount = 10;
                        } else if ((newEntry.Mask & 0xFFFC) == 0x000C) {
                            newEntry.AddrShiftAmount = 14;
                        } else if ((newEntry.Mask & 0xFFF0) == 0x0030) {
                            newEntry.AddrShiftAmount = 16;
                        } else if ((newEntry.Mask & 0xFFC0) == 0x00C0) {
                            newEntry.AddrShiftAmount = 18;
                        } else if ((newEntry.Mask & 0xFF00) == 0x0300) {
                            newEntry.AddrShiftAmount = 20;
                        } else if ((newEntry.Mask & 0xFC00) == 0x0C00) {
                            newEntry.AddrShiftAmount = 22;
                        } else if ((newEntry.Mask & 0xF000) == 0x3000) {
                            newEntry.AddrShiftAmount = 24;
                        } else if ((newEntry.Mask & 0xC000) == 0xC000) {
                            newEntry.AddrShiftAmount = 26;
                        } else if ((newEntry.Mask & 0x30000) == 0x30000) {
                            newEntry.AddrShiftAmount = 28;
                        } else {
                            fatal("Invalid Mask Pattern Detected!\n");
                        }
                        newEntry.OffsetMask =
                            (1 << newEntry.AddrShiftAmount) - 1;

                        MipsISA::TLB *Ptr = xc->tcBase()->getITBPtr();
                        Config3Reg config3 = Config3;
                        PageGrainReg pageGrain = PageGrain;
                        int SP = 0;
                        if (bits(config3, config3.sp) == 1 &&
                            bits(pageGrain, pageGrain.esp) == 1) {
                            SP = 1;
                        }
                        IndexReg index = Index;
                        Ptr->insertAt(newEntry, Random, SP);
                    }});

                    0x08: tlbp({{
                        Config3Reg config3 = Config3;
                        PageGrainReg pageGrain = PageGrain;
                        EntryHiReg entryHi = EntryHi;
                        int tlbIndex;
                        Addr vpn;
                        if (pageGrain.esp == 1 && config3.sp ==1) {
                            vpn = EntryHi >> 11;
                        } else {
                            // Mask off lower 2 bits
                            vpn = ((EntryHi >> 11) & 0xFFFFFFFC);
                        }
                        tlbIndex = xc->tcBase()->getITBPtr()->
                                   probeEntry(vpn, entryHi.asid);
                        // Check TLB for entry matching EntryHi
                        if (tlbIndex != -1) {
                            Index = tlbIndex;
                        } else {
                            // else, set Index = 1 << 31
                            Index = (1 << 31);
                        }
                    }});
                }
                format CP0Unimpl {
                    0x20: wait();
                }
                default: CP0Unimpl::unknown();
            }
        }

        //Table A-13 MIPS32 COP1 Encoding of rs Field
        0x1: decode RS_MSB {
            0x0: decode RS_HI {
                0x0: decode RS_LO {
                    format CP1Control {
                        0x0: mfc1 ({{ Rt.uw = Fs.uw; }});

                        0x2: cfc1({{
                            switch (FS) {
                              case 0:
                                Rt = FIR;
                                break;
                              case 25:
                                Rt = (FCSR & 0xFE000000) >> 24 |
                                     (FCSR & 0x00800000) >> 23;
                                break;
                              case 26:
                                Rt = (FCSR & 0x0003F07C);
                                break;
                              case 28:
                                Rt = (FCSR & 0x00000F80) |
                                     (FCSR & 0x01000000) >> 21 |
                                     (FCSR & 0x00000003);
                                break;
                              case 31:
                                Rt = FCSR;
                                break;
                              default:
                                warn("FP Control Value (%d) Not Valid");
                            }
                        }});

                        0x3: mfhc1({{ Rt.uw = Fs.ud<63:32>; }});

                        0x4: mtc1({{ Fs.uw = Rt.uw; }});

                        0x6: ctc1({{
                            switch (FS) {
                              case 25:
                                FCSR = (Rt.uw<7:1> << 25) |  // move 31-25
                                       (FCSR & 0x01000000) | // bit 24
                                       (FCSR & 0x004FFFFF);  // bit 22-0
                                break;
                              case 26:
                                FCSR = (FCSR & 0xFFFC0000) | // move 31-18
                                       Rt.uw<17:12> << 12 |  // bit 17-12
                                       (FCSR & 0x00000F80) << 7 | // bit 11-7
                                       Rt.uw<6:2> << 2 |     // bit 6-2
                                       (FCSR & 0x00000002);  // bit 1-0
                                break;
                              case 28:
                                FCSR = (FCSR & 0xFE000000) | // move 31-25
                                       Rt.uw<2:2> << 24 |    // bit 24
                                       (FCSR & 0x00FFF000) << 23 | // bit 23-12
                                       Rt.uw<11:7> << 7 |    // bit 24
                                       (FCSR & 0x000007E) |
                                       Rt.uw<1:0>;           // bit 22-0
                                break;
                              case 31:
                                FCSR = Rt.uw;
                                break;

                              default:
                                panic("FP Control Value (%d) "
                                        "Not Available. Ignoring Access "
                                        "to Floating Control Status "
                                        "Register", FS);
                            }
                        }});

                        0x7: mthc1({{
                             uint64_t fs_hi = Rt.uw;
                             uint64_t fs_lo = Fs.ud & 0x0FFFFFFFF;
                             Fs.ud = (fs_hi << 32) | fs_lo;
                        }});

                    }
                    format CP1Unimpl {
                      0x1: dmfc1();
                      0x5: dmtc1();
                    }
                }

                0x1: decode RS_LO {
                    0x0: decode ND {
                        format Branch {
                            0x0: decode TF {
                                0x0: bc1f({{
                                    cond = getCondCode(FCSR, BRANCH_CC) == 0;
                                }});
                                0x1: bc1t({{
                                    cond = getCondCode(FCSR, BRANCH_CC) == 1;
                                }});
                            }
                            0x1: decode TF {
                                0x0: bc1fl({{
                                    cond = getCondCode(FCSR, BRANCH_CC) == 0;
                                }}, Likely);
                                0x1: bc1tl({{
                                    cond = getCondCode(FCSR, BRANCH_CC) == 1;
                                }}, Likely);
                            }
                        }
                    }
                    format CP1Unimpl {
                        0x1: bc1any2();
                        0x2: bc1any4();
                        default: unknown();
                    }
                }
            }

            0x1: decode RS_HI {
                0x2: decode RS_LO {
                    //Table A-14 MIPS32 COP1 Encoding of Function Field When
                    //rs=S (( single-precision floating point))
                    0x0: decode FUNCTION_HI {
                        0x0: decode FUNCTION_LO {
                            format FloatOp {
                                0x0: add_s({{ Fd.sf = Fs.sf + Ft.sf; }});
                                0x1: sub_s({{ Fd.sf = Fs.sf - Ft.sf; }});
                                0x2: mul_s({{ Fd.sf = Fs.sf * Ft.sf; }});
                                0x3: div_s({{ Fd.sf = Fs.sf / Ft.sf; }});
                                0x4: sqrt_s({{ Fd.sf = sqrt(Fs.sf); }});
                                0x5: abs_s({{ Fd.sf = fabs(Fs.sf); }});
                                0x7: neg_s({{ Fd.sf = -Fs.sf; }});
                            }
                            0x6: BasicOp::mov_s({{ Fd.sf = Fs.sf; }});
                        }
                        0x1: decode FUNCTION_LO {
                            format FloatConvertOp {
                                0x0: round_l_s({{ val = Fs.sf; }},
                                               ToLong, Round);
                                0x1: trunc_l_s({{ val = Fs.sf; }},
                                               ToLong, Trunc);
                                0x2: ceil_l_s({{ val = Fs.sf;}},
                                              ToLong, Ceil);
                                0x3: floor_l_s({{ val = Fs.sf; }},
                                               ToLong, Floor);
                                0x4: round_w_s({{ val = Fs.sf; }},
                                               ToWord, Round);
                                0x5: trunc_w_s({{ val = Fs.sf; }},
                                               ToWord, Trunc);
                                0x6: ceil_w_s({{ val = Fs.sf; }},
                                              ToWord, Ceil);
                                0x7: floor_w_s({{ val = Fs.sf; }},
                                               ToWord, Floor);
                            }
                        }

                        0x2: decode FUNCTION_LO {
                            0x1: decode MOVCF {
                                format BasicOp {
                                    0x0: movf_s({{
                                        Fd = (getCondCode(FCSR,CC) == 0) ?
                                             Fs : Fd;
                                    }});
                                    0x1: movt_s({{
                                        Fd = (getCondCode(FCSR,CC) == 1) ?
                                             Fs : Fd;
                                    }});
                                }
                            }

                            format BasicOp {
                                0x2: movz_s({{ Fd = (Rt == 0) ? Fs : Fd; }});
                                0x3: movn_s({{ Fd = (Rt != 0) ? Fs : Fd; }});
                            }

                            format FloatOp {
                                0x5: recip_s({{ Fd = 1 / Fs; }});
                                0x6: rsqrt_s({{ Fd = 1 / sqrt(Fs); }});
                            }
                            format CP1Unimpl {
                                default: unknown();
                            }
                        }
                        0x3: CP1Unimpl::unknown();

                        0x4: decode FUNCTION_LO {
                            format FloatConvertOp {
                                0x1: cvt_d_s({{ val = Fs.sf; }}, ToDouble);
                                0x4: cvt_w_s({{ val = Fs.sf; }}, ToWord);
                                0x5: cvt_l_s({{ val = Fs.sf; }}, ToLong);
                            }

                            0x6: FloatOp::cvt_ps_s({{
                                Fd.ud = (uint64_t) Fs.uw << 32 |
                                        (uint64_t) Ft.uw;
                            }});
                            format CP1Unimpl {
                                default: unknown();
                            }
                        }
                        0x5: CP1Unimpl::unknown();

                        0x6: decode FUNCTION_LO {
                            format FloatCompareOp {
                                0x0: c_f_s({{ cond = 0; }},
                                           SinglePrecision, UnorderedFalse);
                                0x1: c_un_s({{ cond = 0; }},
                                            SinglePrecision, UnorderedTrue);
                                0x2: c_eq_s({{ cond = (Fs.sf == Ft.sf); }},
                                            UnorderedFalse);
                                0x3: c_ueq_s({{ cond = (Fs.sf == Ft.sf); }},
                                             UnorderedTrue);
                                0x4: c_olt_s({{ cond = (Fs.sf < Ft.sf);	}},
                                             UnorderedFalse);
                                0x5: c_ult_s({{ cond = (Fs.sf < Ft.sf); }},
                                             UnorderedTrue);
                                0x6: c_ole_s({{ cond = (Fs.sf <= Ft.sf); }},
                                             UnorderedFalse);
                                0x7: c_ule_s({{ cond = (Fs.sf <= Ft.sf); }},
                                             UnorderedTrue);
                            }
                        }

                        0x7: decode FUNCTION_LO {
                            format FloatCompareOp {
                                0x0: c_sf_s({{ cond = 0; }}, SinglePrecision,
                                            UnorderedFalse, QnanException);
                                0x1: c_ngle_s({{ cond = 0; }}, SinglePrecision,
                                              UnorderedTrue, QnanException);
                                0x2: c_seq_s({{ cond = (Fs.sf == Ft.sf); }},
                                             UnorderedFalse, QnanException);
                                0x3: c_ngl_s({{ cond = (Fs.sf == Ft.sf); }},
                                             UnorderedTrue, QnanException);
                                0x4: c_lt_s({{ cond = (Fs.sf < Ft.sf); }},
                                            UnorderedFalse, QnanException);
                                0x5: c_nge_s({{ cond = (Fs.sf < Ft.sf); }},
                                             UnorderedTrue, QnanException);
                                0x6: c_le_s({{ cond = (Fs.sf <= Ft.sf); }},
                                            UnorderedFalse, QnanException);
                                0x7: c_ngt_s({{ cond = (Fs.sf <= Ft.sf); }},
                                             UnorderedTrue, QnanException);
                            }
                        }
                    }

                    //Table A-15 MIPS32 COP1 Encoding of Function Field When
                    //rs=D
                    0x1: decode FUNCTION_HI {
                        0x0: decode FUNCTION_LO {
                            format FloatOp {
                                0x0: add_d({{ Fd.df = Fs.df + Ft.df; }});
                                0x1: sub_d({{ Fd.df = Fs.df - Ft.df; }});
                                0x2: mul_d({{ Fd.df = Fs.df * Ft.df; }});
                                0x3: div_d({{ Fd.df = Fs.df / Ft.df; }});
                                0x4: sqrt_d({{ Fd.df = sqrt(Fs.df); }});
                                0x5: abs_d({{ Fd.df = fabs(Fs.df); }});
                                0x7: neg_d({{ Fd.df = -1 * Fs.df; }});
                            }
                            0x6: BasicOp::mov_d({{ Fd.df = Fs.df; }});
                        }

                        0x1: decode FUNCTION_LO {
                            format FloatConvertOp {
                                0x0: round_l_d({{ val = Fs.df; }},
                                               ToLong, Round);
                                0x1: trunc_l_d({{ val = Fs.df; }},
                                               ToLong, Trunc);
                                0x2: ceil_l_d({{ val = Fs.df; }},
                                              ToLong, Ceil);
                                0x3: floor_l_d({{ val = Fs.df; }},
                                               ToLong, Floor);
                                0x4: round_w_d({{ val = Fs.df; }},
                                               ToWord, Round);
                                0x5: trunc_w_d({{ val = Fs.df; }},
                                               ToWord, Trunc);
                                0x6: ceil_w_d({{ val = Fs.df; }},
                                              ToWord, Ceil);
                                0x7: floor_w_d({{ val = Fs.df; }},
                                               ToWord, Floor);
                            }
                        }

                        0x2: decode FUNCTION_LO {
                            0x1: decode MOVCF {
                                format BasicOp {
                                    0x0: movf_d({{
                                        Fd.df = (getCondCode(FCSR,CC) == 0) ?
                                                       Fs.df : Fd.df;
                                    }});
                                    0x1: movt_d({{
                                        Fd.df = (getCondCode(FCSR,CC) == 1) ?
                                                       Fs.df : Fd.df;
                                    }});
                                }
                            }

                            format BasicOp {
                                0x2: movz_d({{
                                    Fd.df = (Rt == 0) ? Fs.df : Fd.df;
                                }});
                                0x3: movn_d({{
                                    Fd.df = (Rt != 0) ? Fs.df : Fd.df;
                                }});
                            }

                            format FloatOp {
                                0x5: recip_d({{ Fd.df = 1 / Fs.df; }});
                                0x6: rsqrt_d({{ Fd.df = 1 / sqrt(Fs.df); }});
                            }
                            format CP1Unimpl {
                                default: unknown();
                            }

                        }
                        0x4: decode FUNCTION_LO {
                            format FloatConvertOp {
                                0x0: cvt_s_d({{ val = Fs.df; }}, ToSingle);
                                0x4: cvt_w_d({{ val = Fs.df; }}, ToWord);
                                0x5: cvt_l_d({{ val = Fs.df; }}, ToLong);
                            }
                            default: CP1Unimpl::unknown();
                        }

                        0x6: decode FUNCTION_LO {
                            format FloatCompareOp {
                                0x0: c_f_d({{ cond = 0; }},
                                           DoublePrecision, UnorderedFalse);
                                0x1: c_un_d({{ cond = 0; }},
                                            DoublePrecision, UnorderedTrue);
                                0x2: c_eq_d({{ cond = (Fs.df == Ft.df); }},
                                            UnorderedFalse);
                                0x3: c_ueq_d({{ cond = (Fs.df == Ft.df); }},
                                             UnorderedTrue);
                                0x4: c_olt_d({{ cond = (Fs.df < Ft.df);	}},
                                             UnorderedFalse);
                                0x5: c_ult_d({{ cond = (Fs.df < Ft.df); }},
                                             UnorderedTrue);
                                0x6: c_ole_d({{ cond = (Fs.df <= Ft.df); }},
                                             UnorderedFalse);
                                0x7: c_ule_d({{ cond = (Fs.df <= Ft.df); }},
                                             UnorderedTrue);
                            }
                        }

                        0x7: decode FUNCTION_LO {
                            format FloatCompareOp {
                                0x0: c_sf_d({{ cond = 0; }}, DoublePrecision,
                                            UnorderedFalse, QnanException);
                                0x1: c_ngle_d({{ cond = 0; }}, DoublePrecision,
                                              UnorderedTrue, QnanException);
                                0x2: c_seq_d({{ cond = (Fs.df == Ft.df); }},
                                             UnorderedFalse, QnanException);
                                0x3: c_ngl_d({{ cond = (Fs.df == Ft.df); }},
                                             UnorderedTrue, QnanException);
                                0x4: c_lt_d({{ cond = (Fs.df < Ft.df); }},
                                            UnorderedFalse, QnanException);
                                0x5: c_nge_d({{ cond = (Fs.df < Ft.df); }},
                                             UnorderedTrue, QnanException);
                                0x6: c_le_d({{ cond = (Fs.df <= Ft.df); }},
                                            UnorderedFalse, QnanException);
                                0x7: c_ngt_d({{ cond = (Fs.df <= Ft.df); }},
                                             UnorderedTrue, QnanException);
                            }
                        }
                        default: CP1Unimpl::unknown();
                    }
                    0x2: CP1Unimpl::unknown();
                    0x3: CP1Unimpl::unknown();
                    0x7: CP1Unimpl::unknown();

                    //Table A-16 MIPS32 COP1 Encoding of Function 
                    //Field When rs=W
                    0x4: decode FUNCTION {
                        format FloatConvertOp {
                            0x20: cvt_s_w({{ val = Fs.uw; }}, ToSingle);
                            0x21: cvt_d_w({{ val = Fs.uw; }}, ToDouble);
                            0x26: CP1Unimpl::cvt_ps_w();
                        }
                        default: CP1Unimpl::unknown();
                    }

                    //Table A-16 MIPS32 COP1 Encoding of Function Field
                    //When rs=L1
                    //Note: "1. Format type L is legal only if 64-bit
                    //floating point operations are enabled."
                    0x5: decode FUNCTION_HI {
                        format FloatConvertOp {
                            0x20: cvt_s_l({{ val = Fs.ud; }}, ToSingle);
                            0x21: cvt_d_l({{ val = Fs.ud; }}, ToDouble);
                            0x26: CP1Unimpl::cvt_ps_l();
                        }
                        default: CP1Unimpl::unknown();
                    }

                    //Table A-17 MIPS64 COP1 Encoding of Function Field
                    //When rs=PS1
                    //Note: "1. Format type PS is legal only if 64-bit
                    //floating point operations are enabled. "
                    0x6: decode FUNCTION_HI {
                        0x0: decode FUNCTION_LO {
                            format Float64Op {
                                0x0: add_ps({{
                                    Fd1.sf = Fs1.sf + Ft2.sf;
                                    Fd2.sf = Fs2.sf + Ft2.sf;
                                }});
                                0x1: sub_ps({{
                                    Fd1.sf = Fs1.sf - Ft2.sf;
                                    Fd2.sf = Fs2.sf - Ft2.sf;
                                }});
                                0x2: mul_ps({{
                                    Fd1.sf = Fs1.sf * Ft2.sf;
                                    Fd2.sf = Fs2.sf * Ft2.sf;
                                }});
                                0x5: abs_ps({{
                                    Fd1.sf = fabs(Fs1.sf);
                                    Fd2.sf = fabs(Fs2.sf);
                                }});
                                0x6: mov_ps({{
                                    Fd1.sf = Fs1.sf;
                                    Fd2.sf = Fs2.sf;
                                }});
                                0x7: neg_ps({{
                                    Fd1.sf = -(Fs1.sf);
                                    Fd2.sf = -(Fs2.sf);
                                }});
                                default: CP1Unimpl::unknown();
                            }
                        }
                        0x1: CP1Unimpl::unknown();
                        0x2: decode FUNCTION_LO {
                            0x1: decode MOVCF {
                                format Float64Op {
                                    0x0: movf_ps({{
                                        Fd1 = (getCondCode(FCSR, CC) == 0) ?
                                            Fs1 : Fd1;
                                        Fd2 = (getCondCode(FCSR, CC+1) == 0) ?
                                            Fs2 : Fd2;
                                    }});
                                    0x1: movt_ps({{
                                        Fd2 = (getCondCode(FCSR, CC) == 1) ?
                                            Fs1 : Fd1;
                                        Fd2 = (getCondCode(FCSR, CC+1) == 1) ?
                                            Fs2 : Fd2;
                                    }});
                                }
                            }

                            format Float64Op {
                                0x2: movz_ps({{
                                    Fd1 = (getCondCode(FCSR, CC) == 0) ?
                                        Fs1 : Fd1;
                                    Fd2 = (getCondCode(FCSR, CC) == 0) ?
                                        Fs2 : Fd2;
                                }});
                                0x3: movn_ps({{
                                    Fd1 = (getCondCode(FCSR, CC) == 1) ?
                                        Fs1 : Fd1;
                                    Fd2 = (getCondCode(FCSR, CC) == 1) ?
                                        Fs2 : Fd2;
                                }});
                            }
                            default: CP1Unimpl::unknown();
                        }
                        0x3: CP1Unimpl::unknown();
                        0x4: decode FUNCTION_LO {
                            0x0: FloatOp::cvt_s_pu({{ Fd.sf = Fs2.sf; }});
                            default: CP1Unimpl::unknown();
                        }

                        0x5: decode FUNCTION_LO {
                            0x0: FloatOp::cvt_s_pl({{ Fd.sf = Fs1.sf; }});
                            format Float64Op {
                                0x4: pll({{
                                    Fd.ud = (uint64_t)Fs1.uw << 32 | Ft1.uw;
                                }});
                                0x5: plu({{
                                    Fd.ud = (uint64_t)Fs1.uw << 32 | Ft2.uw;
                                }});
                                0x6: pul({{
                                    Fd.ud = (uint64_t)Fs2.uw << 32 | Ft1.uw;
                                }});
                                0x7: puu({{
                                    Fd.ud = (uint64_t)Fs2.uw << 32 | Ft2.uw;
                                }});
                            }
                            default: CP1Unimpl::unknown();
                        }

                        0x6: decode FUNCTION_LO {
                            format FloatPSCompareOp {
                                0x0: c_f_ps({{ cond1 = 0; }}, {{ cond2 = 0; }},
                                            UnorderedFalse);
                                0x1: c_un_ps({{ cond1 = 0; }}, {{ cond2 = 0; }},
                                             UnorderedTrue);
                                0x2: c_eq_ps({{ cond1 = (Fs1.sf == Ft1.sf); }},
                                             {{ cond2 = (Fs2.sf == Ft2.sf); }},
                                             UnorderedFalse);
                                0x3: c_ueq_ps({{ cond1 = (Fs1.sf == Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf == Ft2.sf); }},
                                              UnorderedTrue);
                                0x4: c_olt_ps({{ cond1 = (Fs1.sf < Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf < Ft2.sf); }},
                                              UnorderedFalse);
                                0x5: c_ult_ps({{ cond1 = (Fs.sf < Ft.sf); }},
                                              {{ cond2 = (Fs2.sf < Ft2.sf); }},
                                              UnorderedTrue);
                                0x6: c_ole_ps({{ cond1 = (Fs.sf <= Ft.sf); }},
                                              {{ cond2 = (Fs2.sf <= Ft2.sf); }},
                                              UnorderedFalse);
                                0x7: c_ule_ps({{ cond1 = (Fs1.sf <= Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf <= Ft2.sf); }},
                                              UnorderedTrue);
                            }
                        }

                        0x7: decode FUNCTION_LO {
                            format FloatPSCompareOp {
                                0x0: c_sf_ps({{ cond1 = 0; }}, {{ cond2 = 0; }},
                                             UnorderedFalse, QnanException);
                                0x1: c_ngle_ps({{ cond1 = 0; }},
                                               {{ cond2 = 0; }},
                                               UnorderedTrue, QnanException);
                                0x2: c_seq_ps({{ cond1 = (Fs1.sf == Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf == Ft2.sf); }},
                                              UnorderedFalse, QnanException);
                                0x3: c_ngl_ps({{ cond1 = (Fs1.sf == Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf == Ft2.sf); }},
                                              UnorderedTrue, QnanException);
                                0x4: c_lt_ps({{ cond1 = (Fs1.sf < Ft1.sf); }},
                                             {{ cond2 = (Fs2.sf < Ft2.sf); }},
                                             UnorderedFalse, QnanException);
                                0x5: c_nge_ps({{ cond1 = (Fs1.sf < Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf < Ft2.sf); }},
                                              UnorderedTrue, QnanException);
                                0x6: c_le_ps({{ cond1 = (Fs1.sf <= Ft1.sf); }},
                                             {{ cond2 = (Fs2.sf <= Ft2.sf); }},
                                             UnorderedFalse, QnanException);
                                0x7: c_ngt_ps({{ cond1 = (Fs1.sf <= Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf <= Ft2.sf); }},
                                              UnorderedTrue, QnanException);
                            }
                        }
                    }
                }
                default: CP1Unimpl::unknown();
            }
        }

        //Table A-19 MIPS32 COP2 Encoding of rs Field
        0x2: decode RS_MSB {
            format CP2Unimpl {
                0x0: decode RS_HI {
                    0x0: decode RS_LO {
                        0x0: mfc2();
                        0x2: cfc2();
                        0x3: mfhc2();
                        0x4: mtc2();
                        0x6: ctc2();
                        0x7: mftc2();
                        default: unknown();
                    }

                    0x1: decode ND {
                        0x0: decode TF {
                            0x0: bc2f();
                            0x1: bc2t();
                            default: unknown();
                        }

                        0x1: decode TF {
                            0x0: bc2fl();
                            0x1: bc2tl();
                            default: unknown();
                        }
                        default: unknown();

                    }
                    default: unknown();
                }
                default: unknown();
            }
        }

        //Table A-20 MIPS64 COP1X Encoding of Function Field 1
        //Note: "COP1X instructions are legal only if 64-bit floating point
        //operations are enabled."
        0x3: decode FUNCTION_HI {
            0x0: decode FUNCTION_LO {
                format LoadIndexedMemory {
                    0x0: lwxc1({{ Fd.uw = Mem.uw; }});
                    0x1: ldxc1({{ Fd.ud = Mem.ud; }});
                    0x5: luxc1({{ Fd.ud = Mem.ud; }},
                               {{ EA = (Rs + Rt) & ~7; }});
                }
            }

            0x1: decode FUNCTION_LO {
                format StoreIndexedMemory {
                    0x0: swxc1({{ Mem.uw = Fs.uw; }});
                    0x1: sdxc1({{ Mem.ud = Fs.ud; }});
                    0x5: suxc1({{ Mem.ud = Fs.ud; }},
                               {{ EA = (Rs + Rt) & ~7; }});
                }
                0x7: Prefetch::prefx({{ EA = Rs + Rt; }});
            }

            0x3: decode FUNCTION_LO {
                0x6: Float64Op::alnv_ps({{
                    if (Rs<2:0> == 0) {
                        Fd.ud = Fs.ud;
                    } else if (Rs<2:0> == 4) {
#if BYTE_ORDER == BIG_ENDIAN
                        Fd.ud = Fs.ud<31:0> << 32 | Ft.ud<63:32>;
#elif BYTE_ORDER == LITTLE_ENDIAN
                        Fd.ud = Ft.ud<31:0> << 32 | Fs.ud<63:32>;
#endif
                    } else {
                        Fd.ud = Fd.ud;
                    }
                }});
            }

            format FloatAccOp {
                0x4: decode FUNCTION_LO {
                    0x0: madd_s({{ Fd.sf = (Fs.sf * Ft.sf) + Fr.sf; }});
                    0x1: madd_d({{ Fd.df = (Fs.df * Ft.df) + Fr.df; }});
                    0x6: madd_ps({{
                        Fd1.sf = (Fs1.df * Ft1.df) + Fr1.df;
                        Fd2.sf = (Fs2.df * Ft2.df) + Fr2.df;
                    }});
                }

                0x5: decode FUNCTION_LO {
                    0x0: msub_s({{ Fd.sf = (Fs.sf * Ft.sf) - Fr.sf; }});
                    0x1: msub_d({{ Fd.df = (Fs.df * Ft.df) - Fr.df; }});
                    0x6: msub_ps({{
                        Fd1.sf = (Fs1.df * Ft1.df) - Fr1.df;
                        Fd2.sf = (Fs2.df * Ft2.df) - Fr2.df;
                    }});
                }

                0x6: decode FUNCTION_LO {
                    0x0: nmadd_s({{ Fd.sf = (-1 * Fs.sf * Ft.sf) - Fr.sf; }});
                    0x1: nmadd_d({{ Fd.df = (-1 * Fs.df * Ft.df) + Fr.df; }});
                    0x6: nmadd_ps({{
                        Fd1.sf = -((Fs1.df * Ft1.df) + Fr1.df);
                        Fd2.sf = -((Fs2.df * Ft2.df) + Fr2.df);
                    }});
                }

                0x7: decode FUNCTION_LO {
                    0x0: nmsub_s({{ Fd.sf = (-1 * Fs.sf * Ft.sf) - Fr.sf; }});
                    0x1: nmsub_d({{ Fd.df = (-1 * Fs.df * Ft.df) - Fr.df; }});
                    0x6: nmsub_ps({{
                        Fd1.sf = -((Fs1.df * Ft1.df) - Fr1.df);
                        Fd2.sf = -((Fs2.df * Ft2.df) - Fr2.df);
                    }});
                }
            }
        }

        format Branch {
            0x4: beql({{ cond = (Rs.sw == Rt.sw); }}, Likely);
            0x5: bnel({{ cond = (Rs.sw != Rt.sw); }}, Likely);
            0x6: blezl({{ cond = (Rs.sw <= 0); }}, Likely);
            0x7: bgtzl({{ cond = (Rs.sw > 0); }}, Likely);
        }
    }

    0x3: decode OPCODE_LO {
        //Table A-5 MIPS32 SPECIAL2 Encoding of Function Field
        0x4: decode FUNCTION_HI {
            0x0: decode FUNCTION_LO {
                0x2: IntOp::mul({{
                    int64_t temp1 = Rs.sd * Rt.sd;
                    Rd.sw = temp1<31:0>;
                }}, IntMultOp);

                format HiLoRdSelValOp {
                    0x0: madd({{
                        val = ((int64_t)HI_RD_SEL << 32 | LO_RD_SEL) +
                              (Rs.sd * Rt.sd);
                    }}, IntMultOp);
                    0x1: maddu({{
                        val = ((uint64_t)HI_RD_SEL << 32 | LO_RD_SEL) +
                              (Rs.ud * Rt.ud);
                    }}, IntMultOp);
                    0x4: msub({{
                        val = ((int64_t)HI_RD_SEL << 32 | LO_RD_SEL) -
                              (Rs.sd * Rt.sd);
                    }}, IntMultOp);
                    0x5: msubu({{
                        val = ((uint64_t)HI_RD_SEL << 32 | LO_RD_SEL) -
                              (Rs.ud * Rt.ud);
                    }}, IntMultOp);
                }
            }

            0x4: decode FUNCTION_LO {
                format BasicOp {
                    0x0: clz({{
                        int cnt = 32;
                        for (int idx = 31; idx >= 0; idx--) {
                            if (Rs<idx:idx> == 1) {
                                cnt = 31 - idx;
                                break;
                            }
                        }
                        Rd.uw = cnt;
                    }});
                    0x1: clo({{
                        int cnt = 32;
                        for (int idx = 31; idx >= 0; idx--) {
                            if (Rs<idx:idx> == 0) {
                                cnt = 31 - idx;
                                break;
                            }
                        }
                        Rd.uw = cnt;
                    }});
                }
            }

            0x7: decode FUNCTION_LO {
                0x7: FailUnimpl::sdbbp();
            }
        }

        //Table A-6 MIPS32 SPECIAL3 Encoding of Function Field for Release 2
        //of the Architecture
        0x7: decode FUNCTION_HI {
            0x0: decode FUNCTION_LO {
                format BasicOp {
                    0x0: ext({{ Rt.uw = bits(Rs.uw, MSB+LSB, LSB); }});
                    0x4: ins({{
                        Rt.uw = bits(Rt.uw, 31, MSB+1) << (MSB+1) |
                                bits(Rs.uw, MSB-LSB, 0) << LSB |
                                bits(Rt.uw, LSB-1, 0);
                    }});
                }
            }

            0x1: decode FUNCTION_LO {
                format MT_Control {
                    0x0: fork({{
                        forkThread(xc->tcBase(), fault, RD, Rs, Rt);
                    }}, UserMode);
                    0x1: yield({{
                        Rd.sw = yieldThread(xc->tcBase(), fault, Rs.sw,
                                            YQMask);
                    }}, UserMode);
                }

                //Table 5-9 MIPS32 LX Encoding of the op Field (DSP ASE MANUAL)
                0x2: decode OP_HI {
                    0x0: decode OP_LO {
                        format LoadIndexedMemory {
                            0x0: lwx({{ Rd.sw = Mem.sw; }});
                            0x4: lhx({{ Rd.sw = Mem.sh; }});
                            0x6: lbux({{ Rd.uw = Mem.ub; }});
                        }
                    }
                }
                0x4: DspIntOp::insv({{
                    int pos = dspctl<5:0>;
                    int size = dspctl<12:7> - 1;
                    Rt.uw = insertBits(Rt.uw, pos+size,
                                       pos, Rs.uw<size:0>);
                }});
            }

            0x2: decode FUNCTION_LO {

                //Table 5-5 MIPS32 ADDU.QB Encoding of the op Field
                //(DSP ASE MANUAL)
                0x0: decode OP_HI {
                    0x0: decode OP_LO {
                        format DspIntOp {
                            0x0: addu_qb({{
                                Rd.uw = dspAdd(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                               NOSATURATE, UNSIGNED, &dspctl);
                            }});
                            0x1: subu_qb({{
                                Rd.uw = dspSub(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                               NOSATURATE, UNSIGNED, &dspctl);
                            }});
                            0x4: addu_s_qb({{
                                Rd.uw = dspAdd(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                               SATURATE, UNSIGNED, &dspctl);
                            }});
                            0x5: subu_s_qb({{
                                Rd.uw = dspSub(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                               SATURATE, UNSIGNED, &dspctl);
                            }});
                            0x6: muleu_s_ph_qbl({{
                                Rd.uw = dspMuleu(Rs.uw, Rt.uw,
                                                 MODE_L, &dspctl);
                            }}, IntMultOp);
                            0x7: muleu_s_ph_qbr({{
                                Rd.uw = dspMuleu(Rs.uw, Rt.uw,
                                                 MODE_R, &dspctl);
                            }}, IntMultOp);
                        }
                    }
                    0x1: decode OP_LO {
                        format DspIntOp {
                            0x0: addu_ph({{
                                Rd.uw = dspAdd(Rs.uw, Rt.uw, SIMD_FMT_PH,
                                               NOSATURATE, UNSIGNED, &dspctl);
                            }});
                            0x1: subu_ph({{
                                Rd.uw = dspSub(Rs.uw, Rt.uw, SIMD_FMT_PH,
                                               NOSATURATE, UNSIGNED, &dspctl);
                            }});
                            0x2: addq_ph({{
                                Rd.uw = dspAdd(Rs.uw, Rt.uw, SIMD_FMT_PH,
                                               NOSATURATE, SIGNED, &dspctl);
                            }});
                            0x3: subq_ph({{
                                Rd.uw = dspSub(Rs.uw, Rt.uw, SIMD_FMT_PH,
                                               NOSATURATE, SIGNED, &dspctl);
                            }});
                            0x4: addu_s_ph({{
                                Rd.uw = dspAdd(Rs.uw, Rt.uw, SIMD_FMT_PH,
                                               SATURATE, UNSIGNED, &dspctl);
                            }});
                            0x5: subu_s_ph({{
                                Rd.uw = dspSub(Rs.uw, Rt.uw, SIMD_FMT_PH,
                                               SATURATE, UNSIGNED, &dspctl);
                            }});
                            0x6: addq_s_ph({{
                                Rd.uw = dspAdd(Rs.uw, Rt.uw, SIMD_FMT_PH,
                                               SATURATE, SIGNED, &dspctl);
                            }});
                            0x7: subq_s_ph({{
                                Rd.uw = dspSub(Rs.uw, Rt.uw, SIMD_FMT_PH,
                                               SATURATE, SIGNED, &dspctl);
                            }});
                        }
                    }
                    0x2: decode OP_LO {
                        format DspIntOp {
                            0x0: addsc({{
                                int64_t dresult;
                                dresult = Rs.ud + Rt.ud;
                                Rd.sw = dresult<31:0>;
                                dspctl = insertBits(dspctl, 13, 13,
                                                    dresult<32:32>);
                            }});
                            0x1: addwc({{
                                int64_t dresult;
                                dresult = Rs.sd + Rt.sd + dspctl<13:13>;
                                Rd.sw = dresult<31:0>;
                                if (dresult<32:32> != dresult<31:31>)
                                    dspctl = insertBits(dspctl, 20, 20, 1);
                            }});
                            0x2: modsub({{
                                Rd.sw = (Rs.sw == 0) ? Rt.sw<23:8> :
                                                       Rs.sw - Rt.sw<7:0>;
                            }});
                            0x4: raddu_w_qb({{
                                Rd.uw = Rs.uw<31:24> + Rs.uw<23:16> +
                                        Rs.uw<15:8> + Rs.uw<7:0>;
                            }});
                            0x6: addq_s_w({{
                                Rd.sw = dspAdd(Rs.sw, Rt.sw, SIMD_FMT_W,
                                               SATURATE, SIGNED, &dspctl);
                            }});
                            0x7: subq_s_w({{
                                Rd.sw = dspSub(Rs.sw, Rt.sw, SIMD_FMT_W,
                                               SATURATE, SIGNED, &dspctl);
                            }});
                        }
                    }
                    0x3: decode OP_LO {
                        format DspIntOp {
                            0x4: muleq_s_w_phl({{
                                Rd.sw = dspMuleq(Rs.sw, Rt.sw,
                                                 MODE_L, &dspctl);
                            }}, IntMultOp);
                            0x5: muleq_s_w_phr({{
                                Rd.sw = dspMuleq(Rs.sw, Rt.sw,
                                                 MODE_R, &dspctl);
                            }}, IntMultOp);
                            0x6: mulq_s_ph({{
                                Rd.sw = dspMulq(Rs.sw, Rt.sw, SIMD_FMT_PH,
                                                SATURATE, NOROUND, &dspctl);
                            }}, IntMultOp);
                            0x7: mulq_rs_ph({{
                                Rd.sw = dspMulq(Rs.sw, Rt.sw, SIMD_FMT_PH,
                                                SATURATE, ROUND, &dspctl);
                            }}, IntMultOp);
                        }
                    }
                }

                //Table 5-6 MIPS32 CMPU_EQ_QB Encoding of the op Field
                //(DSP ASE MANUAL)
                0x1: decode OP_HI {
                    0x0: decode OP_LO {
                        format DspIntOp {
                            0x0: cmpu_eq_qb({{
                                dspCmp(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                       UNSIGNED, CMP_EQ, &dspctl);
                            }});
                            0x1: cmpu_lt_qb({{
                                dspCmp(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                       UNSIGNED, CMP_LT, &dspctl);
                            }});
                            0x2: cmpu_le_qb({{
                                dspCmp(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                       UNSIGNED, CMP_LE, &dspctl);
                            }});
                            0x3: pick_qb({{
                                Rd.uw = dspPick(Rs.uw, Rt.uw,
                                                SIMD_FMT_QB, &dspctl);
                            }});
                            0x4: cmpgu_eq_qb({{
                                Rd.uw = dspCmpg(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                                UNSIGNED, CMP_EQ );
                            }});
                            0x5: cmpgu_lt_qb({{
                                Rd.uw = dspCmpg(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                                UNSIGNED, CMP_LT);
                            }});
                            0x6: cmpgu_le_qb({{
                                Rd.uw = dspCmpg(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                                UNSIGNED, CMP_LE);
                            }});
                        }
                    }
                    0x1: decode OP_LO {
                        format DspIntOp {
                            0x0: cmp_eq_ph({{
                                dspCmp(Rs.uw, Rt.uw, SIMD_FMT_PH,
                                       SIGNED, CMP_EQ, &dspctl);
                            }});
                            0x1: cmp_lt_ph({{
                                dspCmp(Rs.uw, Rt.uw, SIMD_FMT_PH,
                                       SIGNED, CMP_LT, &dspctl);
                            }});
                            0x2: cmp_le_ph({{
                                dspCmp(Rs.uw, Rt.uw, SIMD_FMT_PH,
                                       SIGNED, CMP_LE, &dspctl);
                            }});
                            0x3: pick_ph({{
                                Rd.uw = dspPick(Rs.uw, Rt.uw,
                                                SIMD_FMT_PH, &dspctl);
                            }});
                            0x4: precrq_qb_ph({{
                                Rd.uw = Rs.uw<31:24> << 24 |
                                        Rs.uw<15:8> << 16 |
                                        Rt.uw<31:24> << 8 |
                                        Rt.uw<15:8>;
                            }});
                            0x5: precr_qb_ph({{
                                Rd.uw = Rs.uw<23:16> << 24 |
                                        Rs.uw<7:0> << 16 |
                                        Rt.uw<23:16> << 8 |
                                        Rt.uw<7:0>;
                            }});
                            0x6: packrl_ph({{
                                Rd.uw = dspPack(Rs.uw, Rt.uw, SIMD_FMT_PH);
                            }});
                            0x7: precrqu_s_qb_ph({{
                                Rd.uw = dspPrecrqu(Rs.uw, Rt.uw, &dspctl);
                            }});
                        }
                    }
                    0x2: decode OP_LO {
                        format DspIntOp {
                            0x4: precrq_ph_w({{
                                Rd.uw = Rs.uw<31:16> << 16 | Rt.uw<31:16>;
                            }});
                            0x5: precrq_rs_ph_w({{
                                Rd.uw = dspPrecrq(Rs.uw, Rt.uw,
                                                  SIMD_FMT_W, &dspctl);
                            }});
                        }
                    }
                    0x3: decode OP_LO {
                        format DspIntOp {
                            0x0: cmpgdu_eq_qb({{
                                Rd.uw = dspCmpgd(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                                 UNSIGNED, CMP_EQ, &dspctl);
                            }});
                            0x1: cmpgdu_lt_qb({{
                                Rd.uw = dspCmpgd(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                                 UNSIGNED, CMP_LT, &dspctl);
                            }});
                            0x2: cmpgdu_le_qb({{
                                Rd.uw = dspCmpgd(Rs.uw, Rt.uw, SIMD_FMT_QB,
                                                 UNSIGNED, CMP_LE, &dspctl);
                            }});
                            0x6: precr_sra_ph_w({{
                                Rt.uw = dspPrecrSra(Rt.uw, Rs.uw, RD,
                                                    SIMD_FMT_W, NOROUND);
                            }});
                            0x7: precr_sra_r_ph_w({{
                                Rt.uw = dspPrecrSra(Rt.uw, Rs.uw, RD,
                                                    SIMD_FMT_W, ROUND); 
                            }});
                        }
                    }
                }

                //Table 5-7 MIPS32 ABSQ_S.PH Encoding of the op Field
                //(DSP ASE MANUAL)
                0x2: decode OP_HI {
                    0x0: decode OP_LO {
                        format DspIntOp {
                            0x1: absq_s_qb({{
                                Rd.sw = dspAbs(Rt.sw, SIMD_FMT_QB, &dspctl);
                            }});
                            0x2: repl_qb({{
                                Rd.uw = RS_RT<7:0> << 24 |
                                        RS_RT<7:0> << 16 |
                                        RS_RT<7:0> << 8 |
                                        RS_RT<7:0>;
                            }});
                            0x3: replv_qb({{
                                Rd.sw = Rt.uw<7:0> << 24 |
                                        Rt.uw<7:0> << 16 |
                                        Rt.uw<7:0> << 8 |
                                        Rt.uw<7:0>;
                            }});
                            0x4: precequ_ph_qbl({{
                                Rd.uw = dspPrece(Rt.uw, SIMD_FMT_QB, UNSIGNED,
                                                 SIMD_FMT_PH, SIGNED, MODE_L);
                            }});
                            0x5: precequ_ph_qbr({{
                                Rd.uw = dspPrece(Rt.uw, SIMD_FMT_QB, UNSIGNED,
                                                 SIMD_FMT_PH, SIGNED, MODE_R);
                            }});
                            0x6: precequ_ph_qbla({{
                                Rd.uw = dspPrece(Rt.uw, SIMD_FMT_QB, UNSIGNED,
                                                 SIMD_FMT_PH, SIGNED, MODE_LA);
                            }});
                            0x7: precequ_ph_qbra({{
                                Rd.uw = dspPrece(Rt.uw, SIMD_FMT_QB, UNSIGNED,
                                                 SIMD_FMT_PH, SIGNED, MODE_RA);
                            }});
                        }
                    }
                    0x1: decode OP_LO {
                        format DspIntOp {
                            0x1: absq_s_ph({{
                                Rd.sw = dspAbs(Rt.sw, SIMD_FMT_PH, &dspctl);
                            }});
                            0x2: repl_ph({{
                                Rd.uw = (sext<10>(RS_RT))<15:0> << 16 |
                                        (sext<10>(RS_RT))<15:0>;
                            }});
                            0x3: replv_ph({{
                                Rd.uw = Rt.uw<15:0> << 16 |
                                        Rt.uw<15:0>;
                            }});
                            0x4: preceq_w_phl({{
                                Rd.uw = dspPrece(Rt.uw, SIMD_FMT_PH, SIGNED,
                                                 SIMD_FMT_W, SIGNED, MODE_L);
                            }});
                            0x5: preceq_w_phr({{
                                Rd.uw = dspPrece(Rt.uw, SIMD_FMT_PH, SIGNED,
                                                 SIMD_FMT_W, SIGNED, MODE_R);
                            }});
                        }
                    }
                    0x2: decode OP_LO {
                        format DspIntOp {
                            0x1: absq_s_w({{
                                Rd.sw = dspAbs(Rt.sw, SIMD_FMT_W, &dspctl);
                            }});
                        }
                    }
                    0x3: decode OP_LO {
                        0x3: IntOp::bitrev({{
                            Rd.uw = bitrev( Rt.uw<15:0> );
                        }});
                        format DspIntOp {
                            0x4: preceu_ph_qbl({{
                                Rd.uw = dspPrece(Rt.uw, SIMD_FMT_QB,
                                                 UNSIGNED, SIMD_FMT_PH,
                                                 UNSIGNED, MODE_L);
                            }});
                            0x5: preceu_ph_qbr({{
                                Rd.uw = dspPrece(Rt.uw, SIMD_FMT_QB,
                                                 UNSIGNED, SIMD_FMT_PH,
                                                 UNSIGNED, MODE_R );
                            }});
                            0x6: preceu_ph_qbla({{
                                Rd.uw = dspPrece(Rt.uw, SIMD_FMT_QB,
                                                 UNSIGNED, SIMD_FMT_PH,
                                                 UNSIGNED, MODE_LA );
                            }});
                            0x7: preceu_ph_qbra({{
                                Rd.uw = dspPrece(Rt.uw, SIMD_FMT_QB,
                                                 UNSIGNED, SIMD_FMT_PH,
                                                 UNSIGNED, MODE_RA);
                            }});
                        }
                    }
                }

                //Table 5-8 MIPS32 SHLL.QB Encoding of the op Field
                //(DSP ASE MANUAL)
                0x3: decode OP_HI {
                    0x0: decode OP_LO {
                        format DspIntOp {
                            0x0: shll_qb({{
                                Rd.sw = dspShll(Rt.sw, RS, SIMD_FMT_QB,
                                                NOSATURATE, UNSIGNED, &dspctl);
                            }});
                            0x1: shrl_qb({{
                                Rd.sw = dspShrl(Rt.sw, RS, SIMD_FMT_QB,
                                                UNSIGNED);
                            }});
                            0x2: shllv_qb({{
                                Rd.sw = dspShll(Rt.sw, Rs.sw, SIMD_FMT_QB,
                                                NOSATURATE, UNSIGNED, &dspctl);
                            }});
                            0x3: shrlv_qb({{
                                Rd.sw = dspShrl(Rt.sw, Rs.sw, SIMD_FMT_QB,
                                                UNSIGNED);
                            }});
                            0x4: shra_qb({{
                                Rd.sw = dspShra(Rt.sw, RS, SIMD_FMT_QB,
                                                NOROUND, SIGNED, &dspctl);
                            }});
                            0x5: shra_r_qb({{
                                Rd.sw = dspShra(Rt.sw, RS, SIMD_FMT_QB,
                                                ROUND, SIGNED, &dspctl);
                            }});
                            0x6: shrav_qb({{
                                Rd.sw = dspShra(Rt.sw, Rs.sw, SIMD_FMT_QB,
                                                NOROUND, SIGNED, &dspctl);
                            }});
                            0x7: shrav_r_qb({{
                                Rd.sw = dspShra(Rt.sw, Rs.sw, SIMD_FMT_QB,
                                                ROUND, SIGNED, &dspctl);
                            }});
                        }
                    }
                    0x1: decode OP_LO {
                        format DspIntOp {
                            0x0: shll_ph({{
                                Rd.uw = dspShll(Rt.uw, RS, SIMD_FMT_PH,
                                                NOSATURATE, SIGNED, &dspctl);
                            }});
                            0x1: shra_ph({{
                                Rd.sw = dspShra(Rt.sw, RS, SIMD_FMT_PH,
                                                NOROUND, SIGNED, &dspctl);
                            }});
                            0x2: shllv_ph({{
                                Rd.sw = dspShll(Rt.sw, Rs.sw, SIMD_FMT_PH,
                                                NOSATURATE, SIGNED, &dspctl);
                            }});
                            0x3: shrav_ph({{
                                Rd.sw = dspShra(Rt.sw, Rs.sw, SIMD_FMT_PH,
                                                NOROUND, SIGNED, &dspctl);
                            }});
                            0x4: shll_s_ph({{
                                Rd.sw = dspShll(Rt.sw, RS, SIMD_FMT_PH,
                                                SATURATE, SIGNED, &dspctl);
                            }});
                            0x5: shra_r_ph({{
                                Rd.sw = dspShra(Rt.sw, RS, SIMD_FMT_PH,
                                                ROUND, SIGNED, &dspctl);
                            }});
                            0x6: shllv_s_ph({{
                                Rd.sw = dspShll(Rt.sw, Rs.sw, SIMD_FMT_PH,
                                                SATURATE, SIGNED, &dspctl);
                            }});
                            0x7: shrav_r_ph({{
                                Rd.sw = dspShra(Rt.sw, Rs.sw, SIMD_FMT_PH,
                                                ROUND, SIGNED, &dspctl);
                            }});
                        }
                    }
                    0x2: decode OP_LO {
                        format DspIntOp {
                            0x4: shll_s_w({{
                                Rd.sw = dspShll(Rt.sw, RS, SIMD_FMT_W,
                                                SATURATE, SIGNED, &dspctl);
                            }});
                            0x5: shra_r_w({{
                                Rd.sw = dspShra(Rt.sw, RS, SIMD_FMT_W,
                                                ROUND, SIGNED, &dspctl);
                            }});
                            0x6: shllv_s_w({{
                                Rd.sw = dspShll(Rt.sw, Rs.sw, SIMD_FMT_W,
                                                SATURATE, SIGNED, &dspctl);
                            }});
                            0x7: shrav_r_w({{
                                Rd.sw = dspShra(Rt.sw, Rs.sw, SIMD_FMT_W,
                                                ROUND, SIGNED, &dspctl);
                            }});
                        }
                    }
                    0x3: decode OP_LO {
                        format DspIntOp {
                            0x1: shrl_ph({{
                                Rd.sw = dspShrl(Rt.sw, RS, SIMD_FMT_PH,
                                                UNSIGNED);
                            }});
                            0x3: shrlv_ph({{
                                Rd.sw = dspShrl(Rt.sw, Rs.sw, SIMD_FMT_PH,
                                                UNSIGNED);
                            }});
                        }
                    }
                }
            }

            0x3: decode FUNCTION_LO {

                //Table 3.12 MIPS32 ADDUH.QB Encoding of the op Field
                //(DSP ASE Rev2 Manual)
                0x0: decode OP_HI {
                    0x0: decode OP_LO {
                        format DspIntOp {
                            0x0: adduh_qb({{
                                Rd.uw = dspAddh(Rs.sw, Rt.sw, SIMD_FMT_QB,
                                                NOROUND, UNSIGNED);
                            }});
                            0x1: subuh_qb({{
                                Rd.uw = dspSubh(Rs.sw, Rt.sw, SIMD_FMT_QB,
                                                NOROUND, UNSIGNED);
                            }});
                            0x2: adduh_r_qb({{
                                Rd.uw = dspAddh(Rs.sw, Rt.sw, SIMD_FMT_QB,
                                                ROUND, UNSIGNED);
                            }});
                            0x3: subuh_r_qb({{
                                Rd.uw = dspSubh(Rs.sw, Rt.sw, SIMD_FMT_QB,
                                                ROUND, UNSIGNED);
                            }});
                        }
                    }
                    0x1: decode OP_LO {
                        format DspIntOp {
                            0x0: addqh_ph({{
                                Rd.uw = dspAddh(Rs.sw, Rt.sw, SIMD_FMT_PH,
                                                NOROUND, SIGNED);
                            }});
                            0x1: subqh_ph({{
                                Rd.uw = dspSubh(Rs.sw, Rt.sw, SIMD_FMT_PH,
                                                NOROUND, SIGNED);
                            }});
                            0x2: addqh_r_ph({{
                                Rd.uw = dspAddh(Rs.sw, Rt.sw, SIMD_FMT_PH,
                                                ROUND, SIGNED);
                            }});
                            0x3: subqh_r_ph({{
                                Rd.uw = dspSubh(Rs.sw, Rt.sw, SIMD_FMT_PH,
                                                ROUND, SIGNED);
                            }});
                            0x4: mul_ph({{
                                Rd.sw = dspMul(Rs.sw, Rt.sw, SIMD_FMT_PH,
                                               NOSATURATE, &dspctl);
                            }}, IntMultOp);
                            0x6: mul_s_ph({{
                                Rd.sw = dspMul(Rs.sw, Rt.sw, SIMD_FMT_PH,
                                               SATURATE, &dspctl);
                            }}, IntMultOp);
                        }
                    }
                    0x2: decode OP_LO {
                        format DspIntOp {
                            0x0: addqh_w({{
                                Rd.uw = dspAddh(Rs.sw, Rt.sw, SIMD_FMT_W,
                                                NOROUND, SIGNED);
                            }});
                            0x1: subqh_w({{
                                Rd.uw = dspSubh(Rs.sw, Rt.sw, SIMD_FMT_W,
                                                NOROUND, SIGNED);
                            }});
                            0x2: addqh_r_w({{
                                Rd.uw = dspAddh(Rs.sw, Rt.sw, SIMD_FMT_W,
                                                ROUND, SIGNED);
                            }});
                            0x3: subqh_r_w({{
                                Rd.uw = dspSubh(Rs.sw, Rt.sw, SIMD_FMT_W,
                                                ROUND, SIGNED);
                            }});
                            0x6: mulq_s_w({{
                                Rd.sw = dspMulq(Rs.sw, Rt.sw, SIMD_FMT_W,
                                                SATURATE, NOROUND, &dspctl);
                            }}, IntMultOp);
                            0x7: mulq_rs_w({{
                                Rd.sw = dspMulq(Rs.sw, Rt.sw, SIMD_FMT_W,
                                                SATURATE, ROUND, &dspctl);
                            }}, IntMultOp);
                        }
                    }
                }
            }

            //Table A-10 MIPS32 BSHFL Encoding of sa Field
            0x4: decode SA {
                format BasicOp {
                    0x02: wsbh({{
                        Rd.uw = Rt.uw<23:16> << 24 |
                                Rt.uw<31:24> << 16 |
                                Rt.uw<7:0>   << 8  |
                                Rt.uw<15:8>;
                    }});
                    0x10: seb({{ Rd.sw = Rt.sb; }});
                    0x18: seh({{ Rd.sw = Rt.sh; }});
                }
            }

            0x6: decode FUNCTION_LO {

                //Table 5-10 MIPS32 DPAQ.W.PH Encoding of the op Field
                //(DSP ASE MANUAL)
                0x0: decode OP_HI {
                    0x0: decode OP_LO {
                        format DspHiLoOp {
                            0x0: dpa_w_ph({{
                                dspac = dspDpa(dspac, Rs.sw, Rt.sw, ACDST,
                                               SIMD_FMT_PH, SIGNED, MODE_L);
                            }}, IntMultOp);
                            0x1: dps_w_ph({{
                                dspac = dspDps(dspac, Rs.sw, Rt.sw, ACDST,
                                               SIMD_FMT_PH, SIGNED, MODE_L);
                            }}, IntMultOp);
                            0x2: mulsa_w_ph({{
                                dspac = dspMulsa(dspac, Rs.sw, Rt.sw,
                                                 ACDST, SIMD_FMT_PH );
                            }}, IntMultOp);
                            0x3: dpau_h_qbl({{
                                dspac = dspDpa(dspac, Rs.sw, Rt.sw, ACDST,
                                               SIMD_FMT_QB, UNSIGNED, MODE_L);
                            }}, IntMultOp);
                            0x4: dpaq_s_w_ph({{
                                dspac = dspDpaq(dspac, Rs.sw, Rt.sw,
                                                ACDST, SIMD_FMT_PH,
                                                SIMD_FMT_W, NOSATURATE,
                                                MODE_L, &dspctl);
                            }}, IntMultOp);
                            0x5: dpsq_s_w_ph({{
                                dspac = dspDpsq(dspac, Rs.sw, Rt.sw,
                                                ACDST, SIMD_FMT_PH,
                                                SIMD_FMT_W, NOSATURATE,
                                                MODE_L, &dspctl);
                            }}, IntMultOp);
                            0x6: mulsaq_s_w_ph({{
                                dspac = dspMulsaq(dspac, Rs.sw, Rt.sw,
                                                  ACDST, SIMD_FMT_PH,
                                                  &dspctl);
                            }}, IntMultOp);
                            0x7: dpau_h_qbr({{
                                dspac = dspDpa(dspac, Rs.sw, Rt.sw, ACDST,
                                               SIMD_FMT_QB, UNSIGNED, MODE_R);
                            }}, IntMultOp);
                        }
                    }
                    0x1: decode OP_LO {
                        format DspHiLoOp {
                            0x0: dpax_w_ph({{
                                dspac = dspDpa(dspac, Rs.sw, Rt.sw, ACDST,
                                               SIMD_FMT_PH, SIGNED, MODE_X);
                            }}, IntMultOp);
                            0x1: dpsx_w_ph({{
                                dspac = dspDps(dspac, Rs.sw, Rt.sw, ACDST,
                                               SIMD_FMT_PH, SIGNED, MODE_X);
                            }}, IntMultOp);
                            0x3: dpsu_h_qbl({{
                                dspac = dspDps(dspac, Rs.sw, Rt.sw, ACDST,
                                               SIMD_FMT_QB, UNSIGNED, MODE_L);
                            }}, IntMultOp);
                            0x4: dpaq_sa_l_w({{
                                dspac = dspDpaq(dspac, Rs.sw, Rt.sw,
                                                ACDST, SIMD_FMT_W,
                                                SIMD_FMT_L, SATURATE,
                                                MODE_L, &dspctl);
                            }}, IntMultOp);
                            0x5: dpsq_sa_l_w({{
                                dspac = dspDpsq(dspac, Rs.sw, Rt.sw,
                                                ACDST, SIMD_FMT_W,
                                                SIMD_FMT_L, SATURATE,
                                                MODE_L, &dspctl);
                            }}, IntMultOp);
                            0x7: dpsu_h_qbr({{
                                dspac = dspDps(dspac, Rs.sw, Rt.sw, ACDST,
                                               SIMD_FMT_QB, UNSIGNED, MODE_R);
                            }}, IntMultOp);
                        }
                    }
                    0x2: decode OP_LO {
                        format DspHiLoOp {
                            0x0: maq_sa_w_phl({{
                                dspac = dspMaq(dspac, Rs.uw, Rt.uw,
                                               ACDST, SIMD_FMT_PH,
                                               MODE_L, SATURATE, &dspctl);
                            }}, IntMultOp);
                            0x2: maq_sa_w_phr({{
                                dspac = dspMaq(dspac, Rs.uw, Rt.uw,
                                               ACDST, SIMD_FMT_PH,
                                               MODE_R, SATURATE, &dspctl);
                            }}, IntMultOp);
                            0x4: maq_s_w_phl({{
                                dspac = dspMaq(dspac, Rs.uw, Rt.uw,
                                               ACDST, SIMD_FMT_PH,
                                               MODE_L, NOSATURATE, &dspctl);
                            }}, IntMultOp);
                            0x6: maq_s_w_phr({{
                                dspac = dspMaq(dspac, Rs.uw, Rt.uw,
                                               ACDST, SIMD_FMT_PH,
                                               MODE_R, NOSATURATE, &dspctl);
                            }}, IntMultOp);
                        }
                    }
                    0x3: decode OP_LO {
                        format DspHiLoOp {
                            0x0: dpaqx_s_w_ph({{
                                dspac = dspDpaq(dspac, Rs.sw, Rt.sw,
                                                ACDST, SIMD_FMT_PH,
                                                SIMD_FMT_W, NOSATURATE,
                                                MODE_X, &dspctl);
                            }}, IntMultOp);
                            0x1: dpsqx_s_w_ph({{
                                dspac = dspDpsq(dspac, Rs.sw, Rt.sw,
                                                ACDST, SIMD_FMT_PH,
                                                SIMD_FMT_W, NOSATURATE,
                                                MODE_X, &dspctl);
                            }}, IntMultOp);
                            0x2: dpaqx_sa_w_ph({{
                                dspac = dspDpaq(dspac, Rs.sw, Rt.sw,
                                                ACDST, SIMD_FMT_PH,
                                                SIMD_FMT_W, SATURATE,
                                                MODE_X, &dspctl);
                            }}, IntMultOp);
                            0x3: dpsqx_sa_w_ph({{
                                dspac = dspDpsq(dspac, Rs.sw, Rt.sw,
                                                ACDST, SIMD_FMT_PH,
                                                SIMD_FMT_W, SATURATE,
                                                MODE_X, &dspctl);
                            }}, IntMultOp);
                        }
                    }
                }

                //Table 3.3 MIPS32 APPEND Encoding of the op Field
                0x1: decode OP_HI {
                    0x0: decode OP_LO {
                        format IntOp {
                            0x0: append({{
                                Rt.uw = (Rt.uw << RD) | bits(Rs.uw, RD - 1, 0);
                                }});
                            0x1: prepend({{
                                Rt.uw = (Rt.uw >> RD) |
                                        (bits(Rs.uw, RD - 1, 0) << (32 - RD));
                            }});
                        }
                    }
                    0x2: decode OP_LO {
                        format IntOp {
                            0x0: balign({{
                                Rt.uw = (Rt.uw << (8 * BP)) |
                                        (Rs.uw >> (8 * (4 - BP)));
                            }});
                        }
                    }
                }

            }
            0x7: decode FUNCTION_LO {

                //Table 5-11 MIPS32 EXTR.W Encoding of the op Field
                //(DSP ASE MANUAL)
                0x0: decode OP_HI {
                    0x0: decode OP_LO {
                        format DspHiLoOp {
                            0x0: extr_w({{
                                Rt.uw = dspExtr(dspac, SIMD_FMT_W, RS,
                                                NOROUND, NOSATURATE, &dspctl);
                            }});
                            0x1: extrv_w({{
                                Rt.uw = dspExtr(dspac, SIMD_FMT_W, Rs.uw,
                                                NOROUND, NOSATURATE, &dspctl);
                            }});
                            0x2: extp({{
                                Rt.uw = dspExtp(dspac, RS, &dspctl);
                            }});
                            0x3: extpv({{
                                Rt.uw = dspExtp(dspac, Rs.uw, &dspctl);
                            }});
                            0x4: extr_r_w({{
                                Rt.uw = dspExtr(dspac, SIMD_FMT_W, RS,
                                                ROUND, NOSATURATE, &dspctl);
                            }});
                            0x5: extrv_r_w({{
                                Rt.uw = dspExtr(dspac, SIMD_FMT_W, Rs.uw,
                                                ROUND, NOSATURATE, &dspctl);
                            }});
                            0x6: extr_rs_w({{
                                Rt.uw = dspExtr(dspac, SIMD_FMT_W, RS,
                                                ROUND, SATURATE, &dspctl);
                            }});
                            0x7: extrv_rs_w({{
                                Rt.uw = dspExtr(dspac, SIMD_FMT_W, Rs.uw,
                                                ROUND, SATURATE, &dspctl);
                            }});
                        }
                    }
                    0x1: decode OP_LO {
                        format DspHiLoOp {
                            0x2: extpdp({{
                                Rt.uw = dspExtpd(dspac, RS, &dspctl);
                            }});
                            0x3: extpdpv({{
                                Rt.uw = dspExtpd(dspac, Rs.uw, &dspctl);
                            }});
                            0x6: extr_s_h({{
                                Rt.uw = dspExtr(dspac, SIMD_FMT_PH, RS,
                                                NOROUND, SATURATE, &dspctl);
                            }});
                            0x7: extrv_s_h({{
                                Rt.uw = dspExtr(dspac, SIMD_FMT_PH, Rs.uw,
                                                NOROUND, SATURATE, &dspctl);
                            }});
                        }
                    }
                    0x2: decode OP_LO {
                        format DspIntOp {
                            0x2: rddsp({{
                                Rd.uw = readDSPControl(&dspctl, RDDSPMASK);
                            }});
                            0x3: wrdsp({{
                                writeDSPControl(&dspctl, Rs.uw, WRDSPMASK);
                            }});
                        }
                    }
                    0x3: decode OP_LO {
                        format DspHiLoOp {
                            0x2: shilo({{
                                if (sext<6>(HILOSA) < 0) {
                                    dspac = (uint64_t)dspac <<
                                                -sext<6>(HILOSA);
                                } else {
                                    dspac = (uint64_t)dspac >>
                                                sext<6>(HILOSA);
                                }
                            }});
                            0x3: shilov({{
                                if (sext<6>(Rs.sw<5:0>) < 0) {
                                    dspac = (uint64_t)dspac <<
                                                -sext<6>(Rs.sw<5:0>);
                                } else {
                                    dspac = (uint64_t)dspac >>
                                                sext<6>(Rs.sw<5:0>);
                                }
                            }});
                            0x7: mthlip({{
                                dspac = dspac << 32;
                                dspac |= Rs.uw;
                                dspctl = insertBits(dspctl, 5, 0,
                                                    dspctl<5:0> + 32);
                            }});
                        }
                    }
                }
                0x3: decode OP {
#if FULL_SYSTEM
                    0x0: FailUnimpl::rdhwr();
#else
                    0x0: decode RD {
                        29: BasicOp::rdhwr({{ Rt = TpValue; }});
                    }
#endif
                }
            }
        }
    }

    0x4: decode OPCODE_LO {
        format LoadMemory {
          0x0: lb({{ Rt.sw = Mem.sb; }}, mem_flags = NO_ALIGN_FAULT);
          0x1: lh({{ Rt.sw = Mem.sh; }}, mem_flags = NO_HALF_WORD_ALIGN_FAULT);
            0x3: lw({{ Rt.sw = Mem.sw; }});
            0x4: lbu({{ Rt.uw = Mem.ub;}}, mem_flags = NO_ALIGN_FAULT);
            0x5: lhu({{ Rt.uw = Mem.uh; }},
                     mem_flags = NO_HALF_WORD_ALIGN_FAULT);
        }

        format LoadUnalignedMemory {
            0x2: lwl({{
                uint32_t mem_shift = 24 - (8 * byte_offset);
                Rt.uw = mem_word << mem_shift | (Rt.uw & mask(mem_shift));
            }});
            0x6: lwr({{
                uint32_t mem_shift = 8 * byte_offset;
                Rt.uw = (Rt.uw & (mask(mem_shift) << (32 - mem_shift))) |
                        (mem_word >> mem_shift);
            }});
        }
    }

    0x5: decode OPCODE_LO {
        format StoreMemory {
            0x0: sb({{ Mem.ub = Rt<7:0>; }}, mem_flags = NO_ALIGN_FAULT);
            0x1: sh({{ Mem.uh = Rt<15:0>; }},
                    mem_flags = NO_HALF_WORD_ALIGN_FAULT);
            0x3: sw({{ Mem.uw = Rt<31:0>; }});
        }

        format StoreUnalignedMemory {
            0x2: swl({{
                uint32_t reg_shift = 24 - (8 * byte_offset);
                uint32_t mem_shift = 32 - reg_shift;
                mem_word = (mem_word & (mask(reg_shift) << mem_shift)) |
                           (Rt.uw >> reg_shift);
                }});
            0x6: swr({{
                uint32_t reg_shift = 8 * byte_offset;
                mem_word = Rt.uw << reg_shift |
                           (mem_word & (mask(reg_shift)));
            }});
        }
        format CP0Control {
            0x7: cache({{
                //Addr CacheEA = Rs.uw + OFFSET;
                //fault = xc->CacheOp((uint8_t)CACHE_OP,(Addr) CacheEA);
            }});
        }
    }

    0x6: decode OPCODE_LO {
        format LoadMemory {
            0x0: ll({{ Rt.uw = Mem.uw; }}, mem_flags=LLSC);
            0x1: lwc1({{ Ft.uw = Mem.uw; }});
            0x5: ldc1({{ Ft.ud = Mem.ud; }});
        }
        0x2: CP2Unimpl::lwc2();
        0x6: CP2Unimpl::ldc2();
        0x3: Prefetch::pref();
    }


    0x7: decode OPCODE_LO {
        0x0: StoreCond::sc({{ Mem.uw = Rt.uw; }},
                           {{ uint64_t tmp = write_result;
                              Rt.uw = (tmp == 0 || tmp == 1) ? tmp : Rt.uw;
                           }}, mem_flags=LLSC,
                               inst_flags = IsStoreConditional);
        format StoreMemory {
            0x1: swc1({{ Mem.uw = Ft.uw; }});
            0x5: sdc1({{ Mem.ud = Ft.ud; }});
        }
        0x2: CP2Unimpl::swc2();
        0x6: CP2Unimpl::sdc2();
    }
}


