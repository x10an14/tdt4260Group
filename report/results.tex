\section{Results}
\label{sec:res}

\subsection{TS Results}

\begin{figure}[h]
    \begin{centering}
        \input{tagged-sequential-plot}
        \caption{Speedup using the tagged sequential prefetcher.}
        \label{figure:ts}
    \end{centering}
\end{figure}

As it can be observed in Figure \ref{figure:ts}, the TS configuration with the best
overall benchmark score has degree 1 and distance 6. The speedup with this configuration is 1.030.
In general, degree 1 gives decent results, except when the distance is 10. Increasing the degree only gives worse performance.

The ``\emph{ammp}'' and ``\emph{twolf}'' benchmarks
gave the lowest speedups, with a speedup of 0.759 and 0.983 respectively (speedup
results below 1.000 means the prefetcher actually slows down the application).

This is expected as those applications need to fetch instructions/data from
random locations~\cite[Sec.~4.2]{spec2000-memory}, making it very difficult for the TS prefetcher
to get any benefit from sequential fetching, which relies on spatial locality.

\subsection{DCPT Results}

The figures below show the results from varying only one of the parameters while keeping the others constant.
\begin{figure}[h]
    \begin{centering}
        \input{DCPT-num-deltas-plot}
        \caption{Speedup using the DCPT prefetcher with 98 entries, and 12 bits for each delta.}
        \label{figure:dcpt-num-deltas}
    \end{centering}
\end{figure}

\begin{figure}[h]
    \begin{centering}
        \input{DCPT-table-size-plot}
        \caption{Speedup using the DCPT prefetcher with 19 deltas per entry, and 12 bits for each delta.}
        \label{figure:dcpt-table-size}
    \end{centering}
\end{figure}

\begin{figure}[h]
    \begin{centering}
        \input{DCPT-delta-bits-plot}
        \caption{Speedup using the DCPT prefetcher with 98 entries, and 19 deltas per entry.}
        \label{figure:dcpt-delta-bits}
    \end{centering}
\end{figure}
Number of entries in the table shows both 98 and 196 best results. In order to save size, further simulations are therefore done with 98. The simulations above clearly shows that the optimal number of deltas per entry is 35. Bits per delta needs to be at least 11, but preforms best for 17 or more. 
\todo[inline]{Christian; refs below are not working, you fix? -I}
For further optimization, we combine the parameter values that give the best preformance and additionally test them with some minor variations. These results are shown in table \ref{tab:numdelta} to \ref{tab:deltabits}


\begin{table}[h]
\centering
\label{tab:numdelta}
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
32    & 33    & 34    & \textbf{35}    & 36    & 37    & 38    \\ \hline
1.028 & 1.029 & 1.029 & \textbf{1.033} & 1.027 & 1.028 & 1.027 \\ \hline
\end{tabular}
\smallskip
\caption{Number of deltas}
\end{table}


\begin{table}[h]
\centering
\label{tab:tablesize}
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
95    & 96    & 97    & \textbf{98}    & 99    & 100   & 101   \\ \hline
1.020 & 1.017 & 1.025 & \textbf{1.033} & 1.026 & 1.015 & 1.021 \\ \hline
\end{tabular}
\smallskip
\caption{Table length}
\end{table}


\begin{table}[h]
\centering
\label{tab:deltabits}
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{12}    & 13    & 14    & 15    & 16    \\ \hline
\textbf{1.033} & 1.026 & 1.028 & 1.029 & 1.028 \\ \hline
\end{tabular}
\smallskip
\caption{Bits per delta}
\end{table}

None of the variations proved better than the original one.

\todo[inline]{The results goes here.
\\
- Show that your scheme works\\
- Compare to other schemes that do the same thing. Hopefully you are better, but you need to compare anyway\\
Trick: “Oracle Scheme”\\
- Uses “perfect” information to create an upper bound on the
performance of a class of schemes\\
- Prefetching: Best case is that all L2 accesses are hits\\
Sensitivity analysis: \\
- Check the impact of model assumptions on your
scheme}
