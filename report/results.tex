\section{Results}

\subsection{Tagged sequential}

As described previously, the tagged sequential prefetcher was  implemented with
degree 5 and distance 4, as the performance  with this configuration proved to
be relatively good. The  resulting average speedup was 1.032. The ``ammp'' and
``twolf'' benchmarks gave  really bad results, with a speedup of respectively
0.759 and 0.983  (speedup below zero means the prefetcher actually slows down
the application). This is expected as those applications use large objects and
irregular cache alignment,  which makes it very challenging to predict future
memory accesses using spatial locality.

\todo[inline]{The results goes here.
\\
- Show that your scheme works\\
- Compare to other schemes that do the same thing. Hopefully you are better, but you need to compare anyway\\
Trick: “Oracle Scheme”\\
- Uses “perfect” information to create an upper bound on the
performance of a class of schemes\\
- Prefetching: Best case is that all L2 accesses are hits\\
Sensitivity analysis: \\
- Check the impact of model assumptions on your
scheme}

Our prefetcher was simulated with different combinations of degree and distance,
in the range of 0--6. The combination that got the best overall score on the
benchmark tests was with degree 5 and distance 4.

\begin{figure}[tbp]
\begin{center}
    \input{tagged-sequential-plot}
    \caption{Speedup using the tagged sequential prefetcher}
    \label{graph:tagged-sequential}
\end{center}
\end{figure}

\begin{figure}[tbp]
\begin{center}
    \input{DCPT-plot}
    \caption{Speedup using the DCPT prefetcher}
    \label{graph:dcpt}
\end{center}
\end{figure}
